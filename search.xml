<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode:207. 课程表</title>
      <link href="/2020/04/29/leetcode-207-ke-cheng-biao/"/>
      <url>/2020/04/29/leetcode-207-ke-cheng-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-207-课程表"><a href="#Leetcode-207-课程表" class="headerlink" title="[Leetcode: 207.课程表]"></a>[Leetcode: 207.课程表]</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1]给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: 2, [[1,0]] 输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><pre><code>输入的先决条件是由 边缘列表 表示的图形，而不是 邻接矩阵 。详情请参见图的表示法。你可以假定输入的先决条件中没有重复的边。1 &lt;= numCourses &lt;= 10^5</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用DFS思想，将无前置课程的课程作为初始节点进行DFS遍历，在遍历过程中通过减少子节点依赖前置课程数的方式遍历（当该课程无前置课程时），判断最终的课程数目是否和需要修的课程数相等</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean canFinish(int numCourses, int[][] prerequisites) {        if (numCourses == 0 || prerequisites == null || prerequisites.length == 0 || prerequisites[0] == null || prerequisites[0].length == 0){            return true;        }        int[] dps = new int[numCourses];        List<List<Integer>> numOutput = new ArrayList();        for(int i = 0; i < numCourses; i++){            numOutput.add(new ArrayList<Integer>());        }        for(int[] pre: prerequisites){            numOutput.get(pre[0]).add(pre[1]);            dps[pre[1]] += 1;        }        Queue<Integer> queue = new LinkedList<>();        for(int i = 0; i < numCourses; i++){            if (dps[i] == 0){                queue.offer(i);            }        }        int amount = 0;        while (!queue.isEmpty()){            int getNum = queue.remove();            amount += 1;            for(int num: numOutput.get(getNum)){                dps[num] -= 1;                if (dps[num] == 0){                    queue.offer(num);                }            }        }        return amount == numCourses;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(V+E)$所有节点和边数目</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(V+E)$所有节点和边数目</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:127. 单词接龙</title>
      <link href="/2020/04/28/leetcode-127-dan-ci-jie-long/"/>
      <url>/2020/04/28/leetcode-127-dan-ci-jie-long/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-127-单词接龙"><a href="#Leetcode-127-单词接龙" class="headerlink" title="Leetcode: 127. 单词接龙"></a><a href="https://leetcode-cn.com/problems/word-ladder/" target="_blank" rel="noopener">Leetcode: 127. 单词接龙</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：每次转换只能改变一个字母。转换过程中的中间单词必须是字典中的单词。</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>如果不存在这样的转换序列，返回 0。所有单词具有相同的长度。所有单词只由小写字母组成。字典中不存在重复的单词。你可以假设 beginWord 和 endWord 是非空的，且二者不相同。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出: 5解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,    返回它的长度 5。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: 0解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-BFS"><a href="#思路1-BFS" class="headerlink" title="思路1 BFS"></a>思路1 BFS</h3><p>可将单词接龙看作更改一个单词的无向图，但是需要记录访问的词，所有词都可分解为将一个字符改成*的通用匹配模式，然后使用该通用模型进行匹配，然后使用BFS对图进行广度优先遍历，在广度优先遍历时需要注意要保存层次信息帮助记录路径长</p><h3 id="思路2-双向"><a href="#思路2-双向" class="headerlink" title="思路2 双向"></a>思路2 双向</h3><p>同时从开始词和末尾词进行BFS,减少无用边，更快找到路径，结果为路径加和即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int ladderLength(String beginWord, String endWord, List<String> wordList) {        if (beginWord == null || beginWord.length() == 0 || endWord == null || endWord.length() == 0 || wordList == null || wordList.size() == 0){            return 0;        }        Map<String, List<String>> wordDict = new HashMap<>();        Map<String, Boolean> hasVisit = new HashMap();        Queue<Map<String, Integer>> queue = new LinkedList<>();        hasVisit.put(beginWord, true);        queue.offer(new HashMap<>(){{put(beginWord, 1);}});        for(String word: wordList){            int l = word.length();            if (!word.equals(beginWord)){                hasVisit.put(word, false);            }            for(int i = 0; i < l; i++){                String tempStr = word.substring(0, i) + "*" + word.substring(i + 1, l);                if (!wordDict.containsKey(tempStr)){                    wordDict.put(tempStr, new ArrayList<String>());                }                List<String> tempList = wordDict.get(tempStr);                tempList.add(word);                wordDict.put(tempStr, tempList);            }        }        while(!queue.isEmpty()){            Map<String, Integer> node = queue.remove();            String word = node.keySet().toArray()[0].toString();            int getLevel = node.get(word);            if (word.equals(endWord)){                return getLevel;            }            int l = word.length();            for(int i = 0; i < l; i++){                String tempStr = word.substring(0, i) + "*" + word.substring(i + 1, l);                if (wordDict.get(tempStr) == null || wordDict.get(tempStr).size() == 0){                    continue;                }                for(String getWord: wordDict.get(tempStr)){                    if (getWord.equals(endWord)){                        return getLevel + 1;                    }                    if (!hasVisit.get(getWord)){                        queue.offer(new HashMap<>(){{put(getWord, getLevel + 1);}});                        hasVisit.put(getWord, true);                    }                }            }        }        return 0;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int ladderLength(String beginWord, String endWord, List<String> wordList) {        if (beginWord == null || beginWord.length() == 0 || endWord == null || endWord.length() == 0 || wordList == null || wordList.size() == 0){            return 0;        }        Map<String, List<String>> wordDict = new HashMap<>();        Map<String, Integer> beginVisit = new HashMap<>();        Map<String, Integer> endVisit = new HashMap<>();        Queue<String> beginQueue = new LinkedList<>();        Queue<String> endQueue = new LinkedList<>();        beginVisit.put(beginWord, 1);        endVisit.put(endWord, 1);        beginQueue.offer(beginWord);        endQueue.offer(endWord);        boolean hasEndWord = false;        for(String word: wordList){            int l = word.length();            if (word.equals(endWord)){                hasEndWord = true;            }            for(int i = 0; i < l; i++){                String tempStr = word.substring(0, i) + "*" + word.substring(i + 1, l);                if (!wordDict.containsKey(tempStr)){                    wordDict.put(tempStr, new ArrayList<String>());                }                List<String> tempList = wordDict.get(tempStr);                tempList.add(word);                wordDict.put(tempStr, tempList);            }        }        System.out.println(hasEndWord);        if (!hasEndWord){            return 0;        }        while(!beginQueue.isEmpty() && !endQueue.isEmpty()){            int getSame = updateQueue(wordDict, beginQueue, beginVisit, endVisit);            if (getSame != -1){                return getSame;            }            getSame = updateQueue(wordDict, endQueue, endVisit, beginVisit);            if (getSame != -1){                return getSame;            }        }        return 0;    }    private int updateQueue(Map<String, List<String>> wordDict, Queue<String> queue, Map<String, Integer> visit, Map<String, Integer> visit1){        String getStr = queue.remove();        int l = getStr.length();        int getLever = visit.get(getStr);        for(int i = 0; i < l; i++){            String tempStr = getStr.substring(0, i) + "*" + getStr.substring(i + 1, l);            if (!wordDict.containsKey(tempStr) || wordDict.get(tempStr).size() == 0){                continue;            }            for(String getWord: wordDict.get(tempStr)){                if (!visit.containsKey(getWord)){                    if (visit1.containsKey(getWord)){                        return getLever + visit1.get(getWord);                    }                    queue.offer(getWord);                    visit.put(getWord, getLever + 1);                }            }        }        return -1;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(m*n)$遍历完m个字符长度的n个词</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(m*n)$存储可变换状态</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(m*n)$遍历完m个字符长度的n个词</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(m*n)$存储可变换状态</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:200. 岛屿数量</title>
      <link href="/2020/04/26/leetcode-200-dao-yu-shu-liang/"/>
      <url>/2020/04/26/leetcode-200-dao-yu-shu-liang/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-200-岛屿数量"><a href="#Leetcode-200-岛屿数量" class="headerlink" title="Leetcode:200. 岛屿数量"></a><a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">Leetcode:200. 岛屿数量</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入:11110110101100000000输出: 1示例 2:</code></pre><h3 id="输入"><a href="#输入" class="headerlink" title="输入:"></a>输入:</h3><pre><code>11000110000010000011输出: 3解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-DFS"><a href="#思路1-DFS" class="headerlink" title="思路1 DFS"></a>思路1 DFS</h3><p>在先判断是否是岛屿之后使用DFS对为’1’的岛屿进行深度优先遍历，将状态改为’0’</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>并查集和BFS</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">class Solution {    private int[][] paths = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};    public int numIslands(char[][] grid) {        if (grid == null || grid.length == 0 || grid[0] == null || grid[0].length == 0){            return 0;        }        int m = grid.length;        int n = grid[0].length;        int result = 0;        for(int i = 0; i < m; i++){            for(int j = 0; j < n; j++){                if (grid[i][j] == '1'){                    result += 1;                }                dfs(grid, i, j);            }        }        return result;    }    private void dfs(char[][] grid, int i, int j){        if(grid[i][j] == '0'){            return;        }        int m = grid.length;        int n = grid[0].length;        grid[i][j] = '0';        for(int[] path: paths){            int x = i + path[0];            int y = j + path[1];            if (x >= 0 && x < m && y >= 0 && y < n){                if (grid[x][y] == '1'){                    dfs(grid, x, y);                }            }        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(mn)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(mn)$,栈空间m*n</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:329. 矩阵中的最长递增路径</title>
      <link href="/2020/04/26/leetcode-329-ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing/"/>
      <url>/2020/04/26/leetcode-329-ju-zhen-zhong-de-zui-chang-di-zeng-lu-jing/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/" target="_blank" rel="noopener">Leetcode</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个整数矩阵，找出最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: nums = [[9,9,4],[6,6,8],[2,1,1]] 输出: 4 解释: 最长递增路径为 [1, 2, 6, 9]。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: nums = [[3,4,5],[3,2,6],[2,2,1]] 输出: 4 解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>对每个位置进行深度优先遍历（可看作是四叉树），使用一个与matrix形状相同的数组保存以及经过DFS的节点，然后通过比较与上下左右四个状态比较更新状态</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    private int[][] paths = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};    private int[][] dps;    public int longestIncreasingPath(int[][] matrix) {        if (matrix == null || matrix.length == 0 || matrix[0] == null || matrix[0].length == 0){            return 0;        }        dps = new int[matrix.length][matrix[0].length];        int result = 0;        for(int i = 0; i < matrix.length; i++){            for(int j = 0; j < matrix[0].length; j++){                result = Math.max(dfs(matrix, i, j), result);            }        }        return result;    }    private int dfs(int[][] matrix, int i, int j){        if(dps[i][j] != 0){            return dps[i][j];        }        for(int[] path: paths){            int x = i + path[0];            int y = j + path[1];            if(x >= 0 && x < matrix.length && y >=0 && y < matrix[0].length && matrix[i][j] < matrix[x][y]){                dps[i][j] = Math.max(dps[i][j], dfs(matrix, x, y));            }        }        return ++dps[i][j];    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(mn)$每个单元格仅被计算一次</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(mn)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> DFS </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:322. 零钱兑换</title>
      <link href="/2020/04/25/leetcode-322-ling-qian-dui-huan/"/>
      <url>/2020/04/25/leetcode-322-ling-qian-dui-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-322-零钱兑换"><a href="#Leetcode-322-零钱兑换" class="headerlink" title="Leetcode: 322.零钱兑换"></a><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">Leetcode: 322.零钱兑换</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: coins = [1, 2, 5], amount = 11输出: 3 解释: 11 = 5 + 5 + 1</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: coins = [2], amount = 3输出: -1</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>你可以认为每种硬币的数量是无限的。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>从0开始计算到amount的每个位置的需要硬币的数量，然后按照$dp[i] = min(dp[i - coin] + 1)　coin \in coins$更新状态</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int coinChange(int[] coins, int amount) {        if (coins == null || coins.length == 0){            return -1;        }        int[] dps = new int[amount + 1];        for(int i = 1; i <= amount; i++){            dps[i] = amount + 1;            for(int coin: coins){                if (i - coin >= 0){                    dps[i] = Math.min(dps[i], dps[i - coin] + 1);                }            }        }        return dps[amount] > amount ? -1 : dps[amount];    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(AN)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(A)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:300. 最长上升子序列</title>
      <link href="/2020/04/24/leetcode-300-zui-chang-shang-sheng-zi-xu-lie/"/>
      <url>/2020/04/24/leetcode-300-zui-chang-shang-sheng-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-300-最长上升子序列"><a href="#Leetcode-300-最长上升子序列" class="headerlink" title="Leetcode:300.最长上升子序列"></a><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">Leetcode:300.最长上升子序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个无序的整数数组，找到其中最长上升子序列的长度。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: [10,9,2,5,3,7,101,18]输出: 4 解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-动态规划"><a href="#思路1-动态规划" class="headerlink" title="思路1 动态规划"></a>思路1 动态规划</h3><p>维持每个数字对应的上升子序列长度，然后根据状态转移方程$dp[i] = max(dp[j] + 1)　j\in(nums[j] &lt; nums[i] &amp;&amp; j &lt; i&gt;&gt;)$</p><h3 id="思路2-贪心-二分搜索"><a href="#思路2-贪心-二分搜索" class="headerlink" title="思路2 贪心+二分搜索"></a>思路2 贪心+二分搜索</h3><p>使用一个数组保存从小到大的数字，在相同的上升子序列长度只保留一个值(最小值)，然后每个数字进来二分查找找到合适的位置。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int lengthOfLIS(int[] nums) {        if (nums == null || nums.length == 0){            return 0;        }        int result = 0;        int dps[] = new int[nums.length];        for(int i = 1; i < nums.length; i++){            for(int j = 0; j < i; j++){                if (nums[i] > nums[j]){                    dps[i] = Math.max(dps[j] + 1, dps[i]);                    if (result < dps[i]){                        result = dps[i];                    }                }            }        }        return result + 1;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int lengthOfLIS(int[] nums) {        if (nums == null || nums.length == 0){            return 0;        }        int n = nums.length;        int[] dps = new int[n + 1];        int len = 1;        dps[1] = nums[0];        for(int i = 1; i < n; i++){            if (nums[i] > dps[len]){                dps[++len] = nums[i];                continue;            }            int left  = 1, right = len;            int origin = 0;            while(left <= right){                int mid = (left + right) / 2;                if (dps[mid] < nums[i]){                    origin = mid;                    left = mid + 1;                }else{                    right = mid - 1;                }            }            dps[origin + 1] = nums[i];        }        return len;    } }</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n^2)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(nlogn)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:279. 完全平方数</title>
      <link href="/2020/04/23/leetcode-279-wan-quan-ping-fang-shu/"/>
      <url>/2020/04/23/leetcode-279-wan-quan-ping-fang-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-279-完全平方数"><a href="#Leetcode-279-完全平方数" class="headerlink" title="Leetcode:279. 完全平方数"></a><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">Leetcode:279. 完全平方数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: n = 12输出: 3 解释: 12 = 4 + 4 + 4.</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: n = 13输出: 2解释: 13 = 4 + 9.</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-DP-可开方数保存"><a href="#思路1-DP-可开方数保存" class="headerlink" title="思路1 DP+可开方数保存"></a>思路1 DP+可开方数保存</h3><p>保存可开方数，然后使用$dp[i] = min(dp[i - sqrtNum[j]] + 1)　j \in 开方列表大小$</p><h3 id="思路2-贪心法"><a href="#思路2-贪心法" class="headerlink" title="思路2 贪心法"></a>思路2 贪心法</h3><p>使用一个canSqure函数依次计算是否可以由count个可开方数字加和得到，在这个过程依旧要保存可开方数，用于计算递归计算count - 1个组合而成</p><h3 id="思路3-贪心-BFS"><a href="#思路3-贪心-BFS" class="headerlink" title="思路3 贪心+BFS"></a>思路3 贪心+BFS</h3><p><a href="https://leetcode-cn.com/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode/" target="_blank" rel="noopener">贪心+BFS</a>基本思路是思路2的n元树BFS</p><h3 id="思路4-数学公式"><a href="#思路4-数学公式" class="headerlink" title="思路4 数学公式"></a>思路4 数学公式</h3><p>每个自然数都可以表示为四个整数平方和，且$n!= 4^k(8m + 7) &lt;==&gt; n = a^2 + b^2 + c^2$,所以只需要判断能否表示为三个可开方数之和，如果不能则为4，然后判断是否可以由两个开方数组合而成以及一个可开方数</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int numSquares(int n) {        if (n == 0 || n == 1){            return 1;        }        int[] dps = new int[n + 1];        ArrayList<Integer> sqrtNums = new ArrayList<>();        for(int i = 0; i < n + 1; i++){            if (i >= 1 && i * i <= n){                sqrtNums.add(i * i);            }            dps[i] = i;        }        int sqrtSize = sqrtNums.size();        for(int i = 2; i <= n; i++){            int tempNum = 1;            for(int j = 0; j < sqrtSize && i - sqrtNums.get(j) >= 0; j++){                dps[i] = Math.min(dps[i], dps[i - sqrtNums.get(j)] + 1);            }        }        return dps[n];    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    private Set<Integer> squareSet;    public int numSquares(int n) {        if (n == 0 || n == 1){            return 1;        }        squareSet = new HashSet<>();        for(int i = 0; i * i <= n; i++){            squareSet.add(i * i);        }        for(int i = 1; i <= n; i++){            if (canSquare(n, i)){                return i;            }        }        return n;    }    private boolean canSquare(int n, int count){        if (n < 0){            return false;        }        if (count == 1){            return squareSet.contains(n);        }        for(int num: squareSet){            if (canSquare(n - num, count - 1)){                return true;            }        }        return false;    }}</code></pre><h3 id="代码4"><a href="#代码4" class="headerlink" title="代码4"></a>代码4</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int numSquares(int n) {        while (n % 4 == 0){            n /= 4;        }        if (n % 8 == 7){            return 4;        }        if (isSquare(n)){            return 1;        }        for(int i = 1; i * i <= n; i++){            if (isSquare(n - i * i)){                return 2;            }        }        return 3;    }    private boolean isSquare(int n){        int getSqrt = (int)Math.sqrt(n);        return getSqrt * getSqrt == n;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$ O(n\sqrt{n}) $</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n^{\frac{h}{2}})$,h为递归次数，h可看作是n元树，n为可开方数量，然后最多层数为4根据后续证明</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(\sqrt{n})$</p><h3 id="思路3同思路2"><a href="#思路3同思路2" class="headerlink" title="思路3同思路2"></a>思路3同思路2</h3><h3 id="思路4时间复杂度"><a href="#思路4时间复杂度" class="headerlink" title="思路4时间复杂度"></a>思路4时间复杂度</h3><p>$O(\sqrt{n})$</p><h3 id="思路4空间复杂度"><a href="#思路4空间复杂度" class="headerlink" title="思路4空间复杂度"></a>思路4空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> BFS </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 数学公式 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:198. 打家劫舍</title>
      <link href="/2020/04/22/leetcode-198-da-jia-jie-she/"/>
      <url>/2020/04/22/leetcode-198-da-jia-jie-she/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-198-打家劫舍"><a href="#Leetcode-198-打家劫舍" class="headerlink" title="Leetcode:198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">Leetcode:198. 打家劫舍</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-DP保存所有状态"><a href="#思路1-DP保存所有状态" class="headerlink" title="思路1 DP保存所有状态"></a>思路1 DP保存所有状态</h3><p>DP保存所有状态，然后根据$dps[i] = max(dps[i], nums[i] + dps[j])　j\in[0, i-2]$进行状态更新</p><h3 id="思路2-DP只保存前三个状态"><a href="#思路2-DP只保存前三个状态" class="headerlink" title="思路2 DP只保存前三个状态"></a>思路2 DP只保存前三个状态</h3><p>DP保存前三个状态，然后根据$dps[i] = max(nums[i] + dps[i - 2], nums[i] + dps[i - 3])$进行状态更新</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int rob(int[] nums) {        if (nums == null || nums.length == 0){            return 0;        }        if (nums.length == 1){            return nums[0];        }        int[] dps = new int[nums.length];        for(int i = 0; i < nums.length; i++){            if (i < 2){                dps[i] = nums[i];            }else if(i == 2){                dps[i] = nums[i] + nums[0];            }else{                dps[i] = nums[i] + Math.max(dps[i - 2], dps[i - 3]);            }        }        return Math.max(dps[nums.length - 1], dps[nums.length - 2]);    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int rob(int[] nums) {        if (nums == null || nums.length == 0){            return 0;        }        int pre = 0;        int cur = 0;        for(int num: nums){            int temp = cur;            cur = Math.max(cur, num + pre);            pre = temp;        }        return cur;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>###　思路1时间复杂度<br>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:128. 最长连续序列</title>
      <link href="/2020/04/22/leetcode-128-zui-chang-lian-xu-xu-lie/"/>
      <url>/2020/04/22/leetcode-128-zui-chang-lian-xu-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-128-最长连续序列"><a href="#Leetcode-128-最长连续序列" class="headerlink" title="Leetcode:128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">Leetcode:128. 最长连续序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-排序-遍历"><a href="#思路1-排序-遍历" class="headerlink" title="思路1 排序+遍历"></a>思路1 排序+遍历</h3><p>在对数组进行排序后，依次遍历计算最长的连续序列，注意相等情况</p><h3 id="思路2-hash表-初始值才遍历"><a href="#思路2-hash表-初始值才遍历" class="headerlink" title="思路2 hash表+初始值才遍历"></a>思路2 hash表+初始值才遍历</h3><p>使用一个hash表记录数组中存在的数字，每次都只计算当前数字在且该数字减一不在(避免重复遍历)，然后依次叠加计算最长连续序列</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int longestConsecutive(int[] nums) {        if (nums == null || nums.length == 0){            return 0;        }        Arrays.sort(nums);        int result = 1;        int temp = 1;        for(int i = 1; i < nums.length; i++){            if (nums[i] - nums[i - 1] == 1){                temp += 1;                if (temp > result){                    result = temp;                }            }else if(nums[i] != nums[i - 1]){                temp = 1;             }        }        return result;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int longestConsecutive(int[] nums) {        if (nums == null || nums.length == 0){            return 0;        }        int result = 1;        int temp = 1;        HashSet<Integer> numSet = new HashSet<>();        for(int num: nums){            numSet.add(num);        }        for(int num: nums){            if (!numSet.contains(num - 1)){                temp = 1;                while (numSet.contains(num + 1)){                    temp += 1;                    num ++;                }                if (temp > result){                    result = temp;                }            }        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(nlog(n))$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$若看作排序需要n的空间</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> 排序 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:124. 二叉树中的最大路径和</title>
      <link href="/2020/04/22/leetcode-124-er-cha-shu-zhong-de-zui-da-lu-jing-he/"/>
      <url>/2020/04/22/leetcode-124-er-cha-shu-zhong-de-zui-da-lu-jing-he/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-124-二叉树中的最大路径和"><a href="#Leetcode-124-二叉树中的最大路径和" class="headerlink" title="Leetcode:124. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">Leetcode:124. 二叉树中的最大路径和</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [1,2,3]    1    / \    2   3输出: 6</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [-10,9,20,null,null,15,7]   -10   / \  9  20    /  \   15   7输出: 42</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>后序遍历递归实现，最大路径只能为node+left son + right son或node + left son + node的父节点或node + right son + 父节点，所以在具体实现中后序遍历二叉数，并分别计算比较这三个值即可，递归得到以left son为最高节点的最大路径和right son为最高节点的路径和</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    private int result = Integer.MIN_VALUE;    public int maxPathSum(TreeNode root) {        maxPathCount(root);        return result;    }    private int maxPathCount(TreeNode node){        if (node == null){            return 0;        }        int leftSum = Math.max(maxPathCount(node.left), 0);        int rightSum = Math.max(maxPathCount(node.right), 0);        int newSum = node.val + leftSum + rightSum;        result = Math.max(result, newSum);        return node.val + Math.max(leftSum, rightSum);    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(logn)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> 递归 </tag>
            
            <tag> 后序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:395. 至少有K个重复字符的最长子串</title>
      <link href="/2020/04/21/leetcode-395-zhi-shao-you-k-ge-chong-fu-zi-fu-de-zui-chang-zi-chuan/"/>
      <url>/2020/04/21/leetcode-395-zhi-shao-you-k-ge-chong-fu-zi-fu-de-zui-chang-zi-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-395-至少有K个重复字符的最长子串"><a href="#Leetcode-395-至少有K个重复字符的最长子串" class="headerlink" title="Leetcode:395. 至少有K个重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/" target="_blank" rel="noopener">Leetcode:395. 至少有K个重复字符的最长子串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>找到给定字符串（由小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k 。输出 T 的长度。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入:s = &quot;aaabb&quot;, k = 3输出:3最长子串为 &quot;aaa&quot; ，其中 &#39;a&#39; 重复了 3 次。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入:s = &quot;ababbc&quot;, k = 2输出:5最长子串为 &quot;ababb&quot; ，其中 &#39;a&#39; 重复了 2 次， &#39;b&#39; 重复了 3 次。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>计算字符串中每个字符出现次数，然后是用双指针去除前后不满足的字符。中间字符串遍历，如有少于k次地则切割分治分别计算，并取最大值</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int longestSubstring(String s, int k) {        if (s == null || s.length() == 0 || k > s.length()){            return 0;        }        if (k < 2){            return s.length();        }        return subStringHelper(s, 0, s.length() - 1, k);    }    private int subStringHelper(String s, int start, int end, int k){        if (end - start + 1 < k){            return 0;        }        int[] chNum = new int[26];        for(int i = start; i <= end; i++){            chNum[s.charAt(i) - 'a'] += 1;        }        while(end - start + 1 >= k && chNum[s.charAt(start) - 'a'] < k){            start++;        }        while(end - start + 1 >= k && chNum[s.charAt(end) - 'a'] < k){            end--;        }        if (end - start + 1 < k){            return 0;        }        for(int i = start; i <= end; i++){            if (chNum[s.charAt(i) - 'a'] < k){                return Math.max(subStringHelper(s, start, i - 1, k), subStringHelper(s, i + 1, end, k));            }        }        return end - start + 1;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:315. 计算右侧小于当前元素的个数</title>
      <link href="/2020/04/20/leetcode-315-ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-ge-shu/"/>
      <url>/2020/04/20/leetcode-315-ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-ge-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-315-计算右侧小于当前元素的个数"><a href="#Leetcode-315-计算右侧小于当前元素的个数" class="headerlink" title="Leetcode:315. 计算右侧小于当前元素的个数"></a><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/" target="_blank" rel="noopener">Leetcode:315. 计算右侧小于当前元素的个数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: [5,2,6,1]输出: [2,1,1,0] 解释:5 的右侧有 2 个更小的元素 (2 和 1).2 的右侧仅有 1 个更小的元素 (1).6 的右侧有 1 个更小的元素 (1).1 的右侧有 0 个更小的元素.</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-暴力遍历比较"><a href="#思路1-暴力遍历比较" class="headerlink" title="思路1 暴力遍历比较"></a>思路1 暴力遍历比较</h3><p>直接对每个位置的数和之后的数比较</p><h3 id="思路2-归并排序-索引数组"><a href="#思路2-归并排序-索引数组" class="headerlink" title="思路2 归并排序+索引数组"></a>思路2 归并排序+索引数组</h3><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<Integer> countSmaller(int[] nums) {        ArrayList<Integer> result = new ArrayList<>();        for(int i = 0; i < nums.length; i++){            int count = 0;            for(int j = i + 1; j < nums.length; j++){                if (nums[i] > nums[j]){                    count += 1;                }            }            result.add(count);        }        return result;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    private int[] indexs;    private int[] counters;    private int[] temp;    public List<Integer> countSmaller(int[] nums) {        ArrayList<Integer> result = new ArrayList<>();        indexs = new int[nums.length];        counters = new int[nums.length];        temp = new int[nums.length];        for(int i = 0; i < nums.length; i++){            indexs[i] = i;            counters[i] = 0;        }        mergeSort(nums, 0, nums.length - 1);        for(int i = 0; i < counters.length; i++){            result.add(counters[i]);        }        return result;    }    private void mergeSort(int[] nums, int left, int right){        if (left < right){            int mid = (left + right) / 2;            mergeSort(nums, left, mid);            mergeSort(nums, mid + 1, right);            mergeHelper(nums, left, mid, right);        }    }    private void mergeHelper(int[] nums, int left, int mid , int right){        int tempIndex = left;        int leftIndex = left;        int rightIndex = mid + 1;        while (leftIndex <= mid && rightIndex <= right){            if (nums[indexs[leftIndex]] <= nums[indexs[rightIndex]]){                temp[tempIndex] = indexs[leftIndex];                counters[indexs[leftIndex]] += rightIndex - mid - 1;                leftIndex++;            }else{                temp[tempIndex] = indexs[rightIndex];                rightIndex++;            }            tempIndex++;        }        while(leftIndex <= mid){            temp[tempIndex] = indexs[leftIndex];            counters[indexs[leftIndex]] += rightIndex - mid - 1;            leftIndex++;            tempIndex++;        }        while(rightIndex <= right){            temp[tempIndex] = indexs[rightIndex];            rightIndex++;            tempIndex++;        }        for(int i = left; i <= right; i++){            indexs[i] = temp[i];        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n^2)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(nlog(n))$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> 逆序对 </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 索引数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:218. 天际线问题</title>
      <link href="/2020/04/19/leetcode-218-tian-ji-xian-wen-ti/"/>
      <url>/2020/04/19/leetcode-218-tian-ji-xian-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-218-天际线问题"><a href="#Leetcode-218-天际线问题" class="headerlink" title="Leetcode: 218. 天际线问题"></a><a href="https://leetcode-cn.com/problems/the-skyline-problem/" target="_blank" rel="noopener">Leetcode: 218. 天际线问题</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。现在，假设您获得了城市风光照片（图A）上显示的所有建筑物的位置和高度，请编写一个程序以输出由这些建筑物形成的天际线（图B）。每个建筑物的几何信息用三元组 [Li，Ri，Hi] 表示，其中 Li 和 Ri 分别是第 i 座建筑物左右边缘的 x 坐标，Hi 是其高度。可以保证 0 ≤ Li, Ri ≤ INT_MAX, 0 &lt; Hi ≤ INT_MAX 和 Ri - Li &gt; 0。您可以假设所有建筑物都是在绝对平坦且高度为 0 的表面上的完美矩形。例如，图A中所有建筑物的尺寸记录为：[ [2 9 10], [3 7 15], [5 12 12], [15 20 10], [19 24 8] ] 。输出是以 [ [x1,y1], [x2, y2], [x3, y3], ... ] 格式的“关键点”（图B中的红点）的列表，它们唯一地定义了天际线。关键点是水平线段的左端点。请注意，最右侧建筑物的最后一个关键点仅用于标记天际线的终点，并始终为零高度。此外，任何两个相邻建筑物之间的地面都应被视为天际线轮廓的一部分。例如，图B中的天际线应该表示为：[ [2 10], [3 15], [7 12], [12 0], [15 10], [20 8], [24, 0] ]。</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>任何输入列表中的建筑物数量保证在 [0, 10000] 范围内。输入列表已经按左 x 坐标 Li  进行升序排列。输出列表必须按 x 位排序。输出天际线中不得有连续的相同高度的水平线。例如 [...[2 3], [4 5], [7 5], [11 5], [12 7]...] 是不正确的答案；三条高度为 5 的线应该在最终输出中合并为一个：[...[2 3], [4 5], [12 7], ...]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用分治法，类似与插入排序思路。重点在于看到单个建筑物的应该如何存储。如[1, 5, 9]存为[1, 9],[5, 0],即分好左右节点.<a href="https://leetcode-cn.com/problems/the-skyline-problem/solution/tian-ji-xian-wen-ti-by-leetcode/" target="_blank" rel="noopener">参考</a></p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用最大优先级队列保存最高点，然后根据左右节点以类似入栈出栈形式得到结果。关键在于存储左右节点</p><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><p>可以使用TreeMap使得时间复杂度为$O(nlogn)$<a href="https://leetcode-cn.com/problems/the-skyline-problem/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--45/" target="_blank" rel="noopener">思路</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<List<Integer>> getSkyline(int[][] buildings) {        List<List<Integer>> result = new ArrayList<>();        int n = buildings.length;        if (n == 0){return result;}        if (n == 1){            result.add(new ArrayList<Integer>() {{add(buildings[0][0]); add(buildings[0][2]);}});            result.add(new ArrayList<Integer>() {{add(buildings[0][1]); add(0);}});            return result;        }        List<List<Integer>> left, right;        left = getSkyline(Arrays.copyOfRange(buildings,0, n / 2));        right = getSkyline(Arrays.copyOfRange(buildings, n/2, n));        return mergeResult(left, right);    }    private List<List<Integer>> mergeResult(List<List<Integer>> left, List<List<Integer>> right){        int ls = 0, rs = 0;        int le = left.size(), re = right.size();        int leftY = 0, rightY = 0, curY = 0;        int x, maxY;        List<List<Integer>> result = new ArrayList<>();        while (ls < le && rs < re){            List<Integer> leftP = left.get(ls);            List<Integer> rightP = right.get(rs);            if (leftP.get(0) < rightP.get(0)){                x = leftP.get(0);                ls ++;                leftY = leftP.get(1);            }else{                x = rightP.get(0);                rs ++;                rightY = rightP.get(1);            }            maxY = Math.max(leftY, rightY);            if (curY != maxY){                updateResult(result, x, maxY);                curY = maxY;            }        }        addRest(result, left, ls, le, curY);        addRest(result, right, rs, re, curY);        return result;      }    private void updateResult(List<List<Integer>> result, int x, int y){        if (result.isEmpty() || result.get(result.size() - 1).get(0) != x){            result.add(new ArrayList<Integer>(){{add(x); add(y);}});        }else{            result.get(result.size() - 1).set(1, y);        }    }    private void addRest(List<List<Integer>> result, List<List<Integer>> left, int s, int e, int curY){        while (s < e){            List<Integer> point = left.get(s);            int x = point.get(0);            int y = point.get(1);            s ++;            if (y != curY){                updateResult(result, x, y);                curY = y;            }        }    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<List<Integer>> getSkyline(int[][] buildings) {        List<List<Integer>> result = new ArrayList<>();        if (buildings.length == 0){            return result;        }        List<List<Integer>> marks = new ArrayList<>();        for(int[] nums: buildings){            marks.add(new ArrayList<Integer>(){{add(nums[0]);add(-nums[2]);}});            marks.add(new ArrayList<Integer>(){{add(nums[1]); add(nums[2]);}});        }        Collections.sort(marks, new Comparator<List<Integer>>(){            @Override            public int compare(List<Integer> o1, List<Integer> o2){                int x1 = o1.get(0);                int x2 = o2.get(0);                int y1 = o1.get(1);                int y2 = o2.get(1);                if (x1 != x2){                    return x1 - x2;                }else{                    return y1 - y2;                }            }        });        Queue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>(){            @Override            public int compare(Integer o1, Integer o2){                return o2 - o1;            }        });        queue.offer(0);        int preY = 0;        for(List<Integer> nums: marks){            int x = nums.get(0);            int y = nums.get(1);            if (y < 0){                queue.offer(-y);            }else{                queue.remove(y);            }            int curMax = queue.peek();            if (preY != curMax){                result.add(new ArrayList<Integer>(){{add(x); add(curMax);}});                preY = curMax;            }        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(nlogn)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n^2)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> 分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:287. 寻找重复数</title>
      <link href="/2020/04/17/leetcode-287-xun-zhao-chong-fu-shu/"/>
      <url>/2020/04/17/leetcode-287-xun-zhao-chong-fu-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-287-寻找重复数"><a href="#Leetcode-287-寻找重复数" class="headerlink" title="Leetcode:287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">Leetcode:287. 寻找重复数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [1,3,4,2,2]输出: 2</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [3,1,3,4,2]输出: 3</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>不能更改原数组（假设数组是只读的）。只能使用额外的 O(1) 的空间。时间复杂度小于 O(n2) 。数组中只有一个重复的数字，但它可能不止重复出现一次。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用二分法统计小于mid数量，因为数字在1~n（n+1数组）,若大于mid数量则在左侧，反之右侧</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>快慢指针的思路,因为范围有限以及有重复元素，所以可以看作是链表有环求交点位置</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int findDuplicate(int[] nums) {        int left = 1;        int right = nums.length - 1;        while (left < right){            int mid = (left + right) / 2;            int count = 0;            for(int num: nums){                if (num <= mid){                    count += 1;                }            }            if (count > mid){                right = mid;            }else{                left = mid + 1;            }        }        return left;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int findDuplicate(int[] nums) {        int slow = nums[0];        int fast = nums[0];        do{            slow = nums[slow];            fast = nums[nums[fast]];        }while(slow != fast);        fast = nums[0];        while(slow != fast){            slow = nums[slow];            fast = nums[fast];        }        return slow;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$Onlog(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(1)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 快慢指针 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:162. 寻找峰值</title>
      <link href="/2020/04/17/leetcode-162-xun-zhao-feng-zhi/"/>
      <url>/2020/04/17/leetcode-162-xun-zhao-feng-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-162-寻找峰值"><a href="#Leetcode-162-寻找峰值" class="headerlink" title="Leetcode:162. 寻找峰值"></a><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">Leetcode:162. 寻找峰值</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>峰值元素是指其值大于左右相邻值的元素。给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。你可以假设 nums[-1] = nums[n] = -∞。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: nums = [1,2,3,1]输出: 2解释: 3 是峰值元素，你的函数应该返回其索引 2。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: nums = [1,2,1,3,5,6,4]输出: 1 或 5 解释: 你的函数可以返回索引 1，其峰值元素为 2；     或者返回索引 5， 其峰值元素为 6。</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>你的解法应该是 O(logN) 时间复杂度的。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-遍历"><a href="#思路1-遍历" class="headerlink" title="思路1 遍历"></a>思路1 遍历</h3><p>直接遍历，遍历元素是否大于下一个元素，若大于则返回（从数组列表开始）</p><h3 id="思路2-二分法"><a href="#思路2-二分法" class="headerlink" title="思路2: 二分法"></a>思路2: 二分法</h3><p>可用二分法找峰值，若找的元素大于右侧元素，则需要峰值的元素在mid元素左侧，若小于右侧则为mid右侧</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int findPeakElement(int[] nums) {        if (nums == null){            return -1;        }        for(int i = 0; i < nums.length - 1; i++){            if (nums[i] > nums[i + 1]){                return i;            }        }        return nums.length - 1;    }}</code></pre><h3 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int findPeakElement(int[] nums) {        if (nums == null){            return -1;        }        int left = 0;        int right = nums.length - 1;        while (left < right){            int mid = (left + right) / 2;            if (nums[mid] > nums[mid + 1]){                right = mid;            }else{                left = mid + 1;            }        }        return left;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(1)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(logn)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:324. 摆动排序 II</title>
      <link href="/2020/04/16/leetcode-324-bai-dong-pai-xu-ii/"/>
      <url>/2020/04/16/leetcode-324-bai-dong-pai-xu-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-324-摆动排序-II"><a href="#Leetcode-324-摆动排序-II" class="headerlink" title="Leetcode:324. 摆动排序 II"></a><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/" target="_blank" rel="noopener">Leetcode:324. 摆动排序 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个无序的数组 nums，将它重新排列成 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]... 的顺序。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: nums = [1, 5, 1, 1, 6, 4]输出: 一个可能的答案是 [1, 4, 1, 5, 1, 6]</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: nums = [1, 3, 2, 2, 3, 1]输出: 一个可能的答案是 [2, 3, 1, 3, 1, 2]</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>你可以假设所有输入都会得到有效的结果。</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h3><pre><code>你能用 O(n) 时间复杂度和 / 或原地 O(1) 额外空间来实现吗？</code></pre><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><pre><code>直接使用排序加取后一半位置进行插入到合适的位置，需要注意需要新建一个前半排序和后半排序后的空间，不然由于交换不能到合适的位置(或者用一个map指示排序后每个元素应该在的位置),同时还需要注意最中间的元素等于(nums.length + 1) /2的情况，所以需要能够前后排序空间都逆序，使其中间元素不在一起即在排序时不产生等号</code></pre><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><pre><code>不使用排序而直接使用三partition将数组形成小于中位数的数+中数+大于中位数的数，然后利用两个数组（中间位置之前和之后的数组）逆序，最后根据两个数组得到最后的结果</code></pre><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><pre><code>将两个数组换位虚地址</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public void wiggleSort(int[] nums) {        if (nums == null || nums.length == 0){            return;        }        Arrays.sort(nums);        int mid = (nums.length + 1) / 2;        reverse(nums, 0, mid - 1);        reverse(nums, mid, nums.length - 1);        int[] smallNums = new int[mid];        int[] bigNums = new int[nums.length - mid];        for(int i = 0; i < nums.length; i++){            if (i <= mid - 1){                smallNums[i] = nums[i];            }else{                bigNums[i - mid] = nums[i];            }        }        for(int i = 0; i < nums.length; i++){            if (i % 2 == 0){                nums[i] = smallNums[i / 2];            }else{                nums[i] = bigNums[i / 2];            }        }    }    private void reverse(int[] nums,int start,int end){        while (start < end){            int temp = nums[start];            nums[start++] = nums[end];            nums[end--] = temp;        }    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public void wiggleSort(int[] nums) {        if (nums == null || nums.length == 0 || nums.length == 1){            return;        }        int mid = (nums.length + 1) / 2;        if (nums.length > 1){            quickSelect(nums, 0, nums.length - 1, mid, false);        }        int midNum = nums[mid];        int midIndex = 0, k = nums.length - 1, iterIndex =0;        while (midIndex < k){            if (nums[midIndex] > midNum){                swap(nums, midIndex, k);                k --;            }else if(nums[midIndex] < midNum){                swap(nums, midIndex, iterIndex);                midIndex++;                iterIndex++;            }else{                midIndex++;            }        }        int[] smallNums = new int[mid];        int[] bigNums = new int[nums.length - mid];        for(int i = 0; i < nums.length; i++){            if (i < mid){                smallNums[i] = nums[mid - 1 - i];            }else{                bigNums[i - mid] = nums[nums.length - 1 - (i - mid)];            }        }        for(int i = 0; i < nums.length; i++){            if (i % 2 == 0){                nums[i] =  smallNums[i / 2];            }else{                nums[i] = bigNums[i / 2];            }        }    }    private void quickSelect(int[] nums,int start,int end,int k, boolean reverse){        int getIndex = getPartition(nums, start, end, reverse);        while (getIndex != k){            if (getIndex > k){                getIndex = getPartition(nums, start, getIndex - 1, reverse);            }            if (getIndex < k){                getIndex = getPartition(nums, getIndex + 1, end, reverse);            }        }    }    private int getPartition(int[] nums, int start, int end, boolean reverse){        int getNum = nums[start];        int getIndex = start;        swap(nums, start, end);        for(int i = start; i < end; i++){            if ((!reverse && nums[i] < getNum) || (reverse && nums[i] > getNum)){                swap(nums, getIndex++, i);            }        }        swap(nums, getIndex, end);        return getIndex;    }    private void swap(int[] nums, int i, int j){        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(nlogn)$考虑平均情况</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$考虑平均情况</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p><h3 id="思路3时间复杂度"><a href="#思路3时间复杂度" class="headerlink" title="思路3时间复杂度"></a>思路3时间复杂度</h3><p>$O(n)$考虑平均情况</p><h3 id="思路3空间复杂度"><a href="#思路3空间复杂度" class="headerlink" title="思路3空间复杂度"></a>思路3空间复杂度</h3><p>$O(1)$</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://leetcode-cn.com/problems/wiggle-sort-ii/solution/yi-bu-yi-bu-jiang-shi-jian-fu-za-du-cong-onlognjia/" target="_blank" rel="noopener">Leetcode:324题解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:179. 最大数</title>
      <link href="/2020/04/16/leetcode-179-zui-da-shu/"/>
      <url>/2020/04/16/leetcode-179-zui-da-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-179-最大数"><a href="#Leetcode-179-最大数" class="headerlink" title="Leetcode:179. 最大数"></a><a href="https://leetcode-cn.com/problems/largest-number/" target="_blank" rel="noopener">Leetcode:179. 最大数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [10,2]输出: 210</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [3,30,34,5,9]输出: 9534330</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>输出结果可能非常大，所以你需要返回一个字符串而不是整数。</code></pre><h2 id="思路1：转化为排序-快排"><a href="#思路1：转化为排序-快排" class="headerlink" title="思路1：转化为排序+快排"></a>思路1：转化为排序+快排</h2><p>将数组转化为字符串数组，然后从大到小排序，比较的是str(a)+str(b)与str(b)+str(a),若str(a)+str(b)大，则str(a) &gt; str(b)</p><h2 id="思路2-转化为排序-Java排序"><a href="#思路2-转化为排序-Java排序" class="headerlink" title="思路2: 转化为排序+Java排序"></a>思路2: 转化为排序+Java排序</h2><p>转化为排序然后使用Java内置排序</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public String largestNumber(int[] nums) {        if (nums == null || nums.length == 0){            return "";        }        StringBuilder result = new StringBuilder();        String[] strNums = new String[nums.length];        for(int i = 0; i < nums.length; i++){            strNums[i] = String.valueOf(nums[i]);        }        quickSort(strNums, 0, strNums.length - 1);        if (strNums[0].equals("0")){            return "0";        }        for(int i = 0; i < strNums.length; i++){            result.append(strNums[i]);        }        return result.toString();    }    private void quickSort(String[] nums, int start, int end){        if (start < end){            int getIndex = getPartition(nums, start, end);            quickSort(nums, start, getIndex);            quickSort(nums, getIndex + 1, end);        }    }    private int getPartition(String[] nums, int start, int end){        String getNum = nums[start];        nums[start] = nums[end];        nums[end] = getNum;        int getIndex = start;        for(int i = start; i < end; i++){            if (compare(nums[i], getNum)){                String temp = nums[getIndex];                nums[getIndex] = nums[i];                nums[i] = temp;                getIndex ++;            }        }        nums[end] = nums[getIndex];        nums[getIndex] = getNum;        return getIndex;    }    private boolean compare(String a, String b){        int aCount = a.length();        int bCount = b.length();        int maxCount = aCount > bCount ? aCount : bCount;        char chA = '0';        char chB = '0';        for(int i = 0; i < aCount + bCount; i++){            if (i < aCount){                chA = a.charAt(i);            }else{                chA = b.charAt(i - aCount);            }            if(i < bCount){                chB = b.charAt(i);            }else{                chB = a.charAt(i - bCount);            }            if (chA > chB){                return true;            }else if(chA < chB){                return false;            }        }        return false;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public String largestNumber(int[] nums) {        if (nums == null || nums.length == 0){            return "";        }        StringBuilder result = new StringBuilder();        String[] strNums = new String[nums.length];        for(int i = 0; i < nums.length; i++){            strNums[i] = String.valueOf(nums[i]);        }        Arrays.sort(strNums, new Comparator<String>(){            @Override            public int compare(String a, String b){                int aCount = a.length();                int bCount = b.length();                int maxCount = aCount > bCount ? aCount : bCount;                char chA = '0';                char chB = '0';                for(int i = 0; i < aCount + bCount; i++){                    if (i < aCount){                        chA = a.charAt(i);                    }else{                        chA = b.charAt(i - aCount);                    }                    if(i < bCount){                        chB = b.charAt(i);                    }else{                        chB = a.charAt(i - bCount);                    }                    if (chA != chB){                        return chB - chA;                    }                }                return 0;            }        });        if (strNums[0].equals("0")){            return "0";        }        for(int i = 0; i < strNums.length; i++){            result.append(strNums[i]);        }        return result.toString();    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>最坏$O(n^2)$，平均$O(nlogn)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>最坏$O(n^2)$，平均$O(nlogn)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Attention Bridge:带有Attention Bridge语言无关的多语言神经翻译</title>
      <link href="/2020/04/14/attention-bridge-dai-you-attention-yu-yan-wu-guan-de-duo-yu-yan-shen-jing-fan-yi/"/>
      <url>/2020/04/14/attention-bridge-dai-you-attention-yu-yan-wu-guan-de-duo-yu-yan-shen-jing-fan-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Multilingual-NMT-with-a-language-independent-attention-bridge"><a href="#Multilingual-NMT-with-a-language-independent-attention-bridge" class="headerlink" title="Multilingual NMT with a language-independent attention bridge"></a><a href="https://www.aclweb.org/anthology/W19-4305.pdf" target="_blank" rel="noopener">Multilingual NMT with a language-independent attention bridge</a></h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>作者通过整合跨所有语言共享的中间注意力桥获取到为位机器翻译系统准备的句子表征架构。作者通过在编码端的inner-attention语言特定的编码和解码器连接进行训练。注意力桥利用每种语言的语义进行翻译，并发展成一种语言无关的意义表示，可以有效地用于迁移学习。作者为有效开发多语言神经网络机器翻译提供了一种新的框架。作者在多平行数据上进行了系统性的测试。该模型在双语模型和零样本的翻译上提升较大，展现了该模型的抽象和迁移能力。</p><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul><li>提出了一种多语言翻译系统，有效解决学习语言无关的句子表征任务</li><li>验证了模型能够通过共享表征实现有效的迁移学习和零样本翻译。</li><li>证明了经过多语言训练的词嵌入可以改善大多数下流和展示了从组合翻译任务上获取抽象学习的句子探测任务<h2 id="模型实现"><a href="#模型实现" class="headerlink" title="模型实现"></a>模型实现</h2><h3 id="整体上"><a href="#整体上" class="headerlink" title="整体上"></a>整体上</h3></li></ul><ol><li>使用了标准的encoder-decoder加上attention机制</li><li>加上了self-attention层共享所有的语言对完成语言无关层<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3></li></ol><ul><li>编码器用用BiLSTM得到$n*d_h$句子向量表示，然后使用多层注意力将该表示转换为固定大小的向量$M\in R^{d_h * k}$,k为attention head数量。<br>$$\begin{aligned}<br>  A &amp;= softmax(W_2ReLU(W_1H^T)) \\<br>  M &amp;= AH<br>\end{aligned}$$</li><li>解码器使用通用的带注意力的解码器，该解码器初始向量通过M的平均池化的到。解码器用的是单向的LSTM</li><li>增加惩罚项避免学习到重复的信息。作者使用的是Frobenius正则化解决<br>$$L = -log(p(Y|X)) + ||AA^T - I||_F^2$$<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2></li></ul><ol><li>在双语翻译结果上有所下降，作者解释是因为将有10个self-attention组成的固定的句子向量没有包含多语言信息<br><img src="https://i.loli.net/2020/04/14/KwBSyCF28i7LOq3.png" alt="AB_BLEU_score.png"></li><li>在多对一和一对多的实验中，但是多对一就有一定的效果提升，然后在训练过程中加上了单语数据，具体是将语言A的句子直接复制形成句子对，和平行预料一起进行训练。</li><li>在多对多模型上，在双语模型基础上有了巨大提升，加上单语预料后也有增益。同时在零样本学习上也强于之前的多对一模型。</li><li>训练得到向量在下流任务上结果:在相同预料库下相对于Glove-BoW有所提升，但是可能相对通用的预训练模型微调的效果可能有点不够看，但是为零样本、少样本的跨语言学习提供一种解决方案<br><img src="https://i.loli.net/2020/04/14/NZdJSiUn45mWw7Y.png" alt="AB_DT.png"><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li>对传统的encoder-decoder进行了三项改造:使用了特定语言的encoder-decoder、语言无关的共享attention bridge以及惩罚项。</li><li>使用Attention Bridge合理地将多语言表征融合。该融合是否可以直接用于预训练任务？</li><li>Multi-Head学习到重复内容是否可以使用其他方法进行一种增加“惩罚项”,因为该方法中的Frobenius其实效果提升较小或者对有些任务有负作用<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ol><ul><li><a href="https://www.aclweb.org/anthology/W19-4305.pdf" target="_blank" rel="noopener">Multilingual NMT with a language-independent attention bridge</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> ACL 2019 </tag>
            
            <tag> 机器翻译 </tag>
            
            <tag> 论文阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSRA:Unicoder跨语言预训练模型</title>
      <link href="/2020/04/14/msra-unicoder-kua-yu-yan-yu-xun-lian-mo-xing/"/>
      <url>/2020/04/14/msra-unicoder-kua-yu-yan-yu-xun-lian-mo-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="Unicoder-A-Universal-Language-Encoder-by-Pre-training-with-Multiple-Cross-lingual-Tasks"><a href="#Unicoder-A-Universal-Language-Encoder-by-Pre-training-with-Multiple-Cross-lingual-Tasks" class="headerlink" title="Unicoder: A Universal Language Encoder by Pre-training with Multiple Cross-lingual Tasks"></a><a href="https://www.aclweb.org/anthology/D19-1252.pdf" target="_blank" rel="noopener">Unicoder: A Universal Language Encoder by Pre-training with Multiple Cross-lingual Tasks</a></h1><h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1. 摘要"></a>1. 摘要</h2><p>Unicoder是一个对于不同语言通用的语言编码器。该模型在某个语言的任意NLP任务之后可以直接运用于其他语言。与该方法类似的有Multilingual BERT和XLM，新提出了跨语言的词恢复、释义分类和遮盖语言模型三个预训练任务。这些任务帮助Unicoder学习到了不同语言深层次的内容。同时该方法也发现，在某些任务上进行微调可以让效果得到提升。该模型微调了XNLI和XQA之后，在XLM的基础上，XNLI提升了在15中语言上提升了1.8%，而在XQA上提升了5.5%。</p><h2 id="3-主要贡献"><a href="#3-主要贡献" class="headerlink" title="3. 主要贡献"></a>3. 主要贡献</h2><ol><li>提出了3个跨语言预训练任务，更好的获取语言无关编码</li><li>创建了一个新的跨语言QA数据集XQA</li><li>验证了微调加上语言预训练可以显著提升模型效果</li><li>在XNLI上实现了SOTA<h2 id="4-模型实现"><a href="#4-模型实现" class="headerlink" title="4. 模型实现"></a>4. 模型实现</h2></li><li>在实现上参照了XLM模型，使用BPE共用词表，下采样数据多的语言预料，避免目标语言的词被分为太多的字符级别。</li><li>预训练任务<ul><li>MLM(masked language model) Multilingual Bert</li><li>TLM(translation language model): XLM</li><li>跨语言的词语恢复(Cross-lingual Word Recovery): learn the underlying word alignments between two languages 使用注意力矩阵处理后的X作为input还原X<br>  <img src="https://i.loli.net/2020/04/14/dKLMqOsZuP7clmS.png" alt="Cross-lingual-word-recovery.png"></li><li>跨语言的同义句子分类(Cross-lingual Paraphrase Classification)使用两个不同语言的句子判断两个句子是否是相同的意思，获取两个语言句子层面的对应关系。同时在采样负例时采用两段式的采样方法，首先使用一个轻量级的随机采样方法获取是否是同一含义，然后利用这个模型寻找最相似但是不相等的负样例。该方法主要是使得训练任务难度变高。<br><img src="https://i.loli.net/2020/04/14/3LFxfm6pNSkoMuH.png" alt="Cross-lingual-paraphrase-classfication.png"></li><li>在文档级别上MLM,句子是多语言的。因为跨语言的词级别的多语言较少且可能不通顺，所以需要使用句子组成一个连贯的文档<br><img src="https://i.loli.net/2020/04/14/Qevo1JkBd75qUSP.png" alt="Cross-lingual-masked-language-model.png"></li></ul></li><li>跨语言微调(设目标任务是测试中文数据集)<ul><li>测试数据翻译（Translate Test）将中文的测试数据翻译成英文的测试数据，将问题转化成英文训练、英文测试的问题。<ul><li>训练数据翻译（Translate Train）将英文的训练数据翻译成中文的训练数据，将问题转化成中文训练、中文测试的问题</li><li>跨语言测试（Cross-lingual Test），也就是直接将在英语训练集上训练得到的模型在中文上进行测试。</li></ul></li><li>跨语言微调是通过将英语翻译成其他语言，在英语和其他语言上进行训练，然后再中文数据上进行测试<h2 id="5-实验细节"><a href="#5-实验细节" class="headerlink" title="5. 实验细节"></a>5. 实验细节</h2></li></ul></li><li>训练细节<ul><li>模型结构 12层16头1024个隐层的transformer</li><li>预训练详情 从XLM初始化（节约时间）</li></ul></li><li>数据<ol><li>XNLI：跨语言推理任务</li><li>XQA：新提出数据XQA,Cross-lingual Question Answering,三语数据集，只有英文有训练数据，判断问题和答案是否相关<h2 id="6-实验效果"><a href="#6-实验效果" class="headerlink" title="6. 实验效果"></a>6. 实验效果</h2></li></ol></li><li>XNLI结果:在TRANSLATE-TRAIN的XLM的基础上,多语言微调的整体提升1.8%,其中在使用多语言微调之后提升1.1%,Unicoder相对XLM提升0.7%。所以可以看出Unicoder对多语言的知识掌握能力更强<br><img src="https://i.loli.net/2020/04/14/WiP2mwD4sQq5SFr.png" alt="Unicoder-XNLI-result.png"></li><li>XQA结果:在TRANSLATE-TRAIN的XLM的基础上,多语言微调的整体提升5.5%,其中在使用多语言微调之后提升3.5%,Unicoder相对XLM提升2%<br> <img src="https://i.loli.net/2020/04/14/UNDbA9mfK2jWEdP.png" alt="Unicoder-XQA-result.png"></li><li>总体来说语言越多越好，但是在双语fine-tuning中Vietnamese和Urdu甚至相对单语是有害的<h2 id="7-总结及启迪"><a href="#7-总结及启迪" class="headerlink" title="7. 总结及启迪"></a>7. 总结及启迪</h2></li><li>作者提出了三种全新的预训练任务，三个任务对模型效果均有提升</li><li>提出了一种多语言预训练方案，相对只将原语言翻译效果有提升</li><li>总体而言，在微调阶段，语言越多效果越好</li><li>实践了预训练中多任务的作用，同样也实践了预训练任务的难度对结果影响(Cross-lingual Paraphrase Classification)</li><li>多语言微调是否可以看作是一种数据微调？该模型对于获取翻译之后多语言特征强，所以可以考虑对增强数据的增强捕捉能力？<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2></li></ol><ul><li><a href="https://zhuanlan.zhihu.com/p/86166445" target="_blank" rel="noopener">机器推理系列第三弹：跨语言预训练，提高机器推理的迁移能力</a></li><li><a href="https://www.aclweb.org/anthology/D19-1252.pdf" target="_blank" rel="noopener">Unicoder: A Universal Language Encoder by Pre-training with Multiple Cross-lingual Tasks</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文阅读 </tag>
            
            <tag> EMNLP 2019 </tag>
            
            <tag> 预训练模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:297. 二叉树的序列化与反序列化</title>
      <link href="/2020/04/13/leetcode-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua/"/>
      <url>/2020/04/13/leetcode-297-er-cha-shu-de-xu-lie-hua-yu-fan-xu-lie-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-297-二叉树的序列化与反序列化"><a href="#Leetcode-297-二叉树的序列化与反序列化" class="headerlink" title="Leetcode:297. 二叉树的序列化与反序列化"></a><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">Leetcode:297. 二叉树的序列化与反序列化</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>你可以将以下二叉树： 1/ \2   3    / \    4   5序列化为 &quot;[1,2,3,null,null,4,5]&quot;</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h3><pre><code>这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-BFS-迭代"><a href="#思路1-BFS-迭代" class="headerlink" title="思路1: BFS + 迭代"></a>思路1: BFS + 迭代</h3><p>使用队列进行BFS，记录每个节点进行迭代</p><h3 id="思路2-BFS-递归（TODO-）"><a href="#思路2-BFS-递归（TODO-）" class="headerlink" title="思路2: BFS + 递归（TODO:）"></a>思路2: BFS + 递归（TODO:）</h3><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">public class Codec {    // Encodes a tree to a single string.    public String serialize(TreeNode root) {        Queue<TreeNode> queue = new LinkedList<>();        StringBuilder sb = new StringBuilder();        queue.add(root);        while (!queue.isEmpty()){            TreeNode pre = queue.poll();            if (pre == null){                sb.append("n");                sb.append(",");                continue;            }else{                sb.append(String.valueOf(pre.val));                sb.append(",");            }            queue.offer(pre.left);            queue.offer(pre.right);        }        int neededLength = sb.length() - 1;        // strip speed        while(neededLength > 2 && sb.charAt(neededLength - 1) == 'n'){            neededLength -= 2;        }        sb.setLength(neededLength);        return sb.toString();    }    // Decodes your encoded data to tree.    public TreeNode deserialize(String data) {        if (data.equals("n")){            return null;        }        String[] vals = data.split(",");        TreeNode root = new TreeNode(Integer.valueOf(vals[0]));        Queue<TreeNode> queue = new LinkedList<>();        queue.offer(root);        for(int i = 1; i < vals.length; i += 2){            if (queue.isEmpty()){                break;            }            TreeNode pre = queue.poll();            if (vals[i].equals("n")){                pre.left = null;            }else{                TreeNode left = new TreeNode(Integer.valueOf(vals[i]));                pre.left = left;                queue.offer(left);            }            if (i + 1 >= vals.length){                break;            }            if (vals[i + 1].equals("n")){                pre.right = null;            }else{                TreeNode right = new TreeNode(Integer.valueOf(vals[i + 1]));                pre.right = right;                queue.offer(right);            }        }        return root;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:236. 二叉树的最近公共祖先</title>
      <link href="/2020/04/11/leetcode-236-er-cha-shu-de-zui-jin-gong-gong-zu-xian/"/>
      <url>/2020/04/11/leetcode-236-er-cha-shu-de-zui-jin-gong-gong-zu-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-236-二叉树的最近公共祖先"><a href="#Leetcode-236-二叉树的最近公共祖先" class="headerlink" title="Leetcode: 236. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">Leetcode: 236. 二叉树的最近公共祖先</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>所有节点的值都是唯一的。p、q 为不同节点且均存在于给定的二叉树中。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-后序遍历-递归"><a href="#思路1-后序遍历-递归" class="headerlink" title="思路1: 后序遍历+递归"></a>思路1: 后序遍历+递归</h3><p>使用三个计数器分别计数，通过后序遍历的方式计算每个节点的左子树，右子树以及本身是否包含p,q，如果有两个则表明该节点为最近公共祖先<br>// TODO:其他思路</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        TreeNode result = new TreeNode(0);        commonHelper(root, p, q, result);        return result.left;    }    private boolean commonHelper(TreeNode root, TreeNode p, TreeNode q, TreeNode result){        if (root == null){            return false;        }        int left = commonHelper(root.left, p, q, result) ? 1: 0;        int right = commonHelper(root.right, p, q, result) ? 1: 0;        int mid = 0;        if (root == p || root == q){            mid = 1;        }        if (mid + left + right >= 2){            System.out.println(root.val);            result.left = root;        }        return (mid + left + right) > 0;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode: 230. 二叉搜索树中第K小的元素</title>
      <link href="/2020/04/10/leetcode-230-er-cha-sou-suo-shu-zhong-di-k-xiao-de-yuan-su/"/>
      <url>/2020/04/10/leetcode-230-er-cha-sou-suo-shu-zhong-di-k-xiao-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-230-二叉搜索树中第K小的元素"><a href="#Leetcode-230-二叉搜索树中第K小的元素" class="headerlink" title="Leetcode: 230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode-cn.com/explore/interview/card/top-interview-quesitons/269/tree/1165/" target="_blank" rel="noopener">Leetcode: 230. 二叉搜索树中第K小的元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: root = [3,1,4,null,2], k = 13/ \1   4\   2输出: 1</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: root = [5,3,6,2,4,null,null,1], k = 3    5    / \    3   6    / \2   4/1输出: 3</code></pre><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h3><pre><code>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化 kthSmallest 函数？</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-中序遍历-剪枝-递归"><a href="#思路1-中序遍历-剪枝-递归" class="headerlink" title="思路1 中序遍历+剪枝+递归"></a>思路1 中序遍历+剪枝+递归</h3><p>直接递归使用中序遍历，然后通过设置一个计数器计算数在整个二叉搜索中排序的位置，到达第K小时返回结果（超过K直接返回）</p><h3 id="思路2-中序遍历-剪枝-迭代"><a href="#思路2-中序遍历-剪枝-迭代" class="headerlink" title="思路2 中序遍历+剪枝+迭代"></a>思路2 中序遍历+剪枝+迭代</h3><p>使用一个栈实现中序遍历迭代，通过出栈的数量找到第K个数</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    int numCount;    int result;    public int kthSmallest(TreeNode root, int k) {        numCount = 0;        addSearchNum(root, k);        return result;    }    private void addSearchNum(TreeNode root, int k){        if (root == null || numCount > k){            return;        }        addSearchNum(root.left, k);        numCount ++;        if (numCount == k){            result = root.val;        }        addSearchNum(root.right, k);    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int kthSmallest(TreeNode root, int k) {        Stack<TreeNode> stack = new Stack<>();        while(true){            while (root != null){                stack.push(root);                root = root.left;            }            root = stack.pop();            k --;            if (k == 0) return root.val;            root = root.right;        }    }}</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(N)$需要考虑为所有节点都在左子树</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(N)$可能会有左子树，会有栈的深度</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(N)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(N)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:380. 常数时间插入、删除和获取随机元素</title>
      <link href="/2020/04/09/leetcode-380-chang-shu-shi-jian-cha-ru-shan-chu-he-huo-qu-sui-ji-yuan-su/"/>
      <url>/2020/04/09/leetcode-380-chang-shu-shi-jian-cha-ru-shan-chu-he-huo-qu-sui-ji-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-380-常数时间插入、删除和获取随机元素"><a href="#Leetcode-380-常数时间插入、删除和获取随机元素" class="headerlink" title="Leetcode: 380. 常数时间插入、删除和获取随机元素"></a><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1/" target="_blank" rel="noopener">Leetcode: 380. 常数时间插入、删除和获取随机元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。insert(val)：当元素 val 不存在时，向集合中插入该项。remove(val)：元素 val 存在时，从集合中移除该项。getRandom：随机返回现有集合中的一项。每个元素应该有相同的概率被返回。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例 :"></a>示例 :</h3><pre><code>// 初始化一个空的集合。RandomizedSet randomSet = new RandomizedSet();// 向集合中插入 1 。返回 true 表示 1 被成功地插入。randomSet.insert(1);// 返回 false ，表示集合中不存在 2 。randomSet.remove(2);// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。randomSet.insert(2);// getRandom 应随机返回 1 或 2 。randomSet.getRandom();// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。randomSet.remove(1);// 2 已在集合中，所以返回 false 。randomSet.insert(2);// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。randomSet.getRandom();</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>首先满足插入和删除为O(1)的容器会想到哈希表，然后需要返回集合中的随机数，需要一个增长列表。同时需要满足插入和删除为O(1)可以直接将需要删除的数置于末尾，然后删除，插入不变。在插入和删除过程中需要同时更新哈希表和增长列表。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class RandomizedSet {    /** Initialize your data structure here. */    private HashMap<Integer, Integer> numMap;    private List<Integer> nums;    private Random random;    public RandomizedSet() {        numMap = new HashMap<>();        nums = new ArrayList<>();        random = new Random();    }    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */    public boolean insert(int val) {        if (numMap.containsKey(val)){            return false;        }        numMap.put(val, nums.size());        nums.add(val);        return true;    }    /** Removes a value from the set. Returns true if the set contained the specified element. */    public boolean remove(int val) {        if (!numMap.containsKey(val)){            return false;        }        int getIndex = numMap.get(val);        int getNum = nums.get(nums.size() - 1);        numMap.put(getNum, getIndex);        nums.set(getIndex, getNum);        nums.remove(nums.size() - 1);        numMap.remove(val);        return true;    }    /** Get a random element from the set. */    public int getRandom() {        return nums.get(random.nextInt(nums.size()));    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(1)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> Collection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:454. 四数相加 II</title>
      <link href="/2020/04/08/leetcode-454-si-shu-xiang-jia-ii/"/>
      <url>/2020/04/08/leetcode-454-si-shu-xiang-jia-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-454-四数相加II"><a href="#Leetcode-454-四数相加II" class="headerlink" title="Leetcode:454. 四数相加II"></a><a href="https://leetcode-cn.com/problems/4sum-ii" target="_blank" rel="noopener">Leetcode:454. 四数相加II</a></h1><pre><code>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</code></pre><h3 id="例如"><a href="#例如" class="headerlink" title="例如:"></a>例如:</h3><pre><code>输入:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]输出:2解释:两个元组如下:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>two sum扩展，直接使用一个哈希表存储A、B列表之和个数，然后遍历满足所有数相交为0的C、D之和，得到最后的结果</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {        if (A == null || A.length == 0 || B == null || B.length == 0 || C == null || C.length == 0 || D == null || D.length == 0){            return 0;        }        Map<Integer, Integer> dictAB = new HashMap<>();        int result = 0;        for (int i = 0; i < A.length; i++){            for(int j = 0; j < B.length; j++){                int tempSum = A[i] + B[j];                if (!dictAB.containsKey(tempSum)){                    dictAB.put(tempSum, 1);                }else{                    dictAB.put(A[i] + B[j], dictAB.get(tempSum) + 1);                }            }        }        for(int i = 0; i < C.length; i++){            for(int j = 0; j < D.length; j++){                int tempSum = C[i] + D[j];                if (dictAB.containsKey(-tempSum)){                    result += dictAB.get(-tempSum);                }            }        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n^2)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n^2)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:171. Excel表列序号</title>
      <link href="/2020/04/08/leetcode-171-excel-biao-lie-xu-hao/"/>
      <url>/2020/04/08/leetcode-171-excel-biao-lie-xu-hao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-171-Excel表列序号"><a href="#Leetcode-171-Excel表列序号" class="headerlink" title="Leetcode: 171. Excel表列序号"></a><a href="https://leetcode-cn.com/problems/excel-sheet-column-number/" target="_blank" rel="noopener">Leetcode: 171. Excel表列序号</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个Excel表格中的列名称，返回其相应的列序号。</code></pre><h3 id="例如，"><a href="#例如，" class="headerlink" title="例如，"></a>例如，</h3><pre><code>A -&gt; 1B -&gt; 2C -&gt; 3...Z -&gt; 26AA -&gt; 27AB -&gt; 28 ...</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: &quot;A&quot;输出: 1</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: &quot;AB&quot;输出: 28</code></pre><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><pre><code>输入: &quot;ZY&quot;输出: 701</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接使用26进制思路遍历字符串即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int titleToNumber(String s) {        if (s == null || s.length() == 0){            return 0;        }        int result = 0;        for(int i = 0; i < s.length(); i++){            result = result * 26 + s.charAt(i) - 'A' + 1;        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:328. 奇偶链表</title>
      <link href="/2020/04/08/leetcode-328-qi-ou-lian-biao/"/>
      <url>/2020/04/08/leetcode-328-qi-ou-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-328-奇偶链表"><a href="#Leetcode-328-奇偶链表" class="headerlink" title="Leetcode:328. 奇偶链表"></a><a href="https://leetcode-cn.com/problems/odd-even-linked-list" target="_blank" rel="noopener">Leetcode:328. 奇偶链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接使用四个指针分别之前奇数节点起点、遍历；偶数节点、遍历；然后交替更换即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public ListNode oddEvenList(ListNode head) {        if (head == null || head.next == null){            return head;        }        ListNode even = head.next;        ListNode evenPre = even;        ListNode oddEnd = head;        while(evenPre != null && evenPre.next != null){            oddEnd.next = evenPre.next;            oddEnd = oddEnd.next;            evenPre.next = oddEnd.next;            evenPre = evenPre.next;        }        oddEnd.next = even;        return head;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:237. 删除链表中的节点</title>
      <link href="/2020/04/07/leetcode-237-shan-chu-lian-biao-zhong-de-jie-dian/"/>
      <url>/2020/04/07/leetcode-237-shan-chu-lian-biao-zhong-de-jie-dian/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-237-删除链表中的节点"><a href="#Leetcode-237-删除链表中的节点" class="headerlink" title="Leetcode: 237. 删除链表中的节点"></a><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list" target="_blank" rel="noopener">Leetcode: 237. 删除链表中的节点</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。现有一个链表 -- head = [4,5,1,9]，它可以表示为:</code></pre><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h2><pre><code>输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>链表至少包含两个节点。链表中所有节点的值都是唯一的。给定的节点为非末尾节点并且一定是链表中的一个有效节点。不要从你的函数中返回任何结果。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>根据题目描述（不为最后一个节点）可以直接将该节点下一个节点的值赋给当前值，然后删除下一个节点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public void deleteNode(ListNode node) {        if (node == null || node.next == null){            return;        }        node.val = node.next.val;        node.next = node.next.next;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(1)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:234. 回文链表</title>
      <link href="/2020/04/07/leetcode-234-hui-wen-lian-biao/"/>
      <url>/2020/04/07/leetcode-234-hui-wen-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-234-回文链表"><a href="#Leetcode-234-回文链表" class="headerlink" title="Leetcode:234.回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list" target="_blank" rel="noopener">Leetcode:234.回文链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>请判断一个链表是否为回文链表。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: 1-&gt;2输出: false</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: 1-&gt;2-&gt;2-&gt;1输出: true</code></pre><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h3><pre><code>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-转化为数组再判断"><a href="#思路1-转化为数组再判断" class="headerlink" title="思路1:转化为数组再判断"></a>思路1:转化为数组再判断</h3><p>将链表使用一个列表存储，然后再判断数组是否是回文</p><h3 id="思路2-修改原链表，将后半部分链表反向"><a href="#思路2-修改原链表，将后半部分链表反向" class="headerlink" title="思路2: 修改原链表，将后半部分链表反向"></a>思路2: 修改原链表，将后半部分链表反向</h3><p>使用快慢指针得到链表中间位置，然后对后半部分链表进行反转然后比较判断是否是回文链表</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean isPalindrome(ListNode head) {        if (head == null || head.next == null){            return true;        }        ArrayList<Integer> getNums = new ArrayList<>();        ListNode pre = head;        while(pre != null){            getNums.add(pre.val);            pre = pre.next;        }        int arraySize = getNums.size();        for(int i = 0; i < arraySize / 2; i++){            if (!getNums.get(i).equals(getNums.get(arraySize - i - 1))){                return false;            }        }        return true;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean isPalindrome(ListNode head) {        if (head == null || head.next == null){            return true;        }        ListNode fast = head, slow = head;        while (fast != null && fast.next != null){            fast = fast.next.next;            slow = slow.next;        }        ListNode pre = null;        ListNode forward = slow.next;        while(slow != null){            slow.next = pre;            pre = slow;            slow = forward;            if (forward != null){                forward = forward.next;            }        }        forward = head;        while(pre != null){            if (forward.val != pre.val){                return false;            }            pre = pre.next;            forward = forward.next;        }        return true;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂U盾"><a href="#思路2空间复杂U盾" class="headerlink" title="思路2空间复杂U盾"></a>思路2空间复杂U盾</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:206. 反转链表</title>
      <link href="/2020/04/07/leetcode-206-fan-zhuan-lian-biao/"/>
      <url>/2020/04/07/leetcode-206-fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-206-反转链表"><a href="#Leetcode-206-反转链表" class="headerlink" title="Leetcode:206.反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Leetcode:206.反转链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>反转一个单链表。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</code></pre><h2 id="思路1-迭代"><a href="#思路1-迭代" class="headerlink" title="思路1:迭代"></a>思路1:迭代</h2><p>使用三个指针分别指向之前，现在和将来的位置，然后遍历逆转即可</p><h2 id="思路2-递归"><a href="#思路2-递归" class="headerlink" title="思路2:递归"></a>思路2:递归</h2><p>需要考虑从尾指针开始，然后开始递归，即考虑从后开始。然后利用当前指针的下一个位置进行递归，然后逆转。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public ListNode reverseList(ListNode head) {        if (head == null || head.next == null){            return head;        }        ListNode pre = null;        ListNode now = head;        ListNode forward = head.next;        while(now != null){            now.next = pre;            pre = now;            now = forward;            if (forward != null){                forward = forward.next;            }        }        return pre;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution2 {    public ListNode reverseList(ListNode head) {        if (head == null || head.next == null){            return head;        }        ListNode pre = reverseList(head.next);        head.next.next = head;        head.next = null;        return pre;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(1)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$会使用n层栈空间</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:160. 相交链表</title>
      <link href="/2020/04/06/leetcode-160-xiang-jiao-lian-biao/"/>
      <url>/2020/04/06/leetcode-160-xiang-jiao-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-160-相交链表"><a href="#Leetcode-160-相交链表" class="headerlink" title="[Leetcode:160.相交链表]"></a>[Leetcode:160.相交链表]</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>编写一个程序，找到两个单链表相交的起始节点。如下面的两个链表：在节点 c1 开始相交。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><pre><code>如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>对链表的节点数量计数后分别遍历，然后长的链表先遍历完注定不相交的前段，然后开始同时遍历知道相同</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {       if ((headA == null && headB != null) || (headA != null && headB == null)){          return null;       }        int countA = 0, countB = 0;        ListNode preA = headA, preB = headB;        while (preA != null){            preA = preA.next;            countA += 1;        }        while (preB != null){            preB = preB.next;            countB += 1;        }        preA = headA;        preB = headB;        while(countA > countB){            preA = preA.next;            countA--;        }        while(countA < countB){            preB = preB.next;            countB--;        }        while(preA != null){            if (preA == preB){                return preA;            }            preA = preA.next;            preB = preB.next;        }        return null;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="代码1时间复杂度"><a href="#代码1时间复杂度" class="headerlink" title="代码1时间复杂度"></a>代码1时间复杂度</h3><p>$O(n)$</p><h3 id="代码1空间复杂度"><a href="#代码1空间复杂度" class="headerlink" title="代码1空间复杂度"></a>代码1空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:148. 排序链表</title>
      <link href="/2020/04/06/leetcode-148-pai-xu-lian-biao/"/>
      <url>/2020/04/06/leetcode-148-pai-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>#<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">Leetcode: 141.排序链表</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用快排实现，值修改</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用归并排序，实现平均复杂度$O(n)$,因为链表可以直接引用空间，所以可以不用额外的$O(nlogn)$空间，需要注意获取中间节点的快指针位置初始设置</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><pre class=" language-Java"><code class="language-Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode sortList(ListNode head) {        if (head == null || head.next == null){            return head;        }        quickSort(head, null);        return head;    }    private void quickSort(ListNode head, ListNode end){        if (head != end){            ListNode midNode = getPartition(head, end);            quickSort(head, midNode);            quickSort(midNode.next, end);        }    }    private ListNode getPartition(ListNode head, ListNode end){        ListNode getNode = head;        int getNum = head.val;        ListNode pre = head.next;        while(pre != null){            if (pre == end){                break;            }            if (pre.val < getNum){                getNode = getNode.next;                int tempNum = pre.val;                pre.val = getNode.val;                getNode.val = tempNum;            }            pre = pre.next;        }        int tempNum = getNode.val;        getNode.val = head.val;        head.val = tempNum;        return getNode;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode sortList(ListNode head) {        if (head == null || head.next == null){            return head;        }        ListNode pre = head.next;        ListNode middle = head;        while (pre != null && pre.next != null){            pre = pre.next.next;            middle = middle.next;        }        pre = middle.next;        middle.next = null;        ListNode left = sortList(head);        ListNode right = sortList(pre);        ListNode result = new ListNode(0);        ListNode temp = result;        while (left != null && right != null){            if (left.val < right.val){                temp.next = left;                left = left.next;            }else{                temp.next = right;                right = right.next;            }            temp = temp.next;        }        temp.next = right;        if (left != null){            temp.next = left;        }        return result.next;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>最坏$O(n^2)$，平均$O(nlogn)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(1)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(nlogn)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 快排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:141. 环形链表</title>
      <link href="/2020/04/06/leetcode-141-huan-xing-lian-biao/"/>
      <url>/2020/04/06/leetcode-141-huan-xing-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-141-环形链表"><a href="#Leetcode-141-环形链表" class="headerlink" title="Leetcode:141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Leetcode:141. 环形链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h3><pre><code>你能用 O(1)（即，常量）内存解决此问题吗？</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>快慢指针，使用快慢指针遍历链表看是否会有相交</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public boolean hasCycle(ListNode head) {        if (head == null || head.next == null){            return false;        }        ListNode fast = head;        ListNode slow = head;        do{            slow = slow.next;            fast = fast.next != null ? fast.next.next : null;        }        while (fast != null && slow != null && (fast != slow));        if (fast == slow && fast != null){            return true;        }else{            return false;        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:138. 复制带随机指针的链表</title>
      <link href="/2020/04/06/leetcode-138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/"/>
      <url>/2020/04/06/leetcode-138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-138-复制带随机指针的链表"><a href="#Leetcode-138-复制带随机指针的链表" class="headerlink" title="Leetcode:138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer" target="_blank" rel="noopener">Leetcode:138. 复制带随机指针的链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的 深拷贝。 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：val：一个表示 Node.val 的整数。random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]</code></pre><h3 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h3><pre><code>输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><pre><code>-10000 &lt;= Node.val &lt;= 10000Node.random 为空（null）或指向链表中的节点。节点数目不超过 1000 。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>//TODO：其他思路</p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接在原来的链表位置旁复制，然后遍历分离</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">/*// Definition for a Node.class Node {    int val;    Node next;    Node random;    public Node(int val) {        this.val = val;        this.next = null;        this.random = null;    }}*/class Solution {    public Node copyRandomList(Node head) {        if (head == null){            return null;        }        Node pre = head;        while(pre != null){            Node newNode = new Node(pre.val);            newNode.next = pre.next;            pre.next = newNode;            pre = pre.next.next;        }        pre = head;        while(pre != null){            if (pre.next != null && pre.random != null){                pre.next.random = pre.random.next;            } else {                pre.next.random = null;            }            pre = pre.next.next;        }        Node origin = head;        pre = head.next;        Node result = head.next;        while(pre != null){            origin.next = origin.next.next;            if (pre.next == null){                pre.next = null;            }else{                pre.next = pre.next.next;            }            origin = origin.next;            pre = pre.next;        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度分析"><a href="#思路1空间复杂度分析" class="headerlink" title="思路1空间复杂度分析"></a>思路1空间复杂度分析</h3><p>$O(1)$如果不算结果空间</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:150. 逆波兰表达式求值</title>
      <link href="/2020/04/05/leetcode-150-ni-bo-lan-biao-da-shi-qiu-zhi/"/>
      <url>/2020/04/05/leetcode-150-ni-bo-lan-biao-da-shi-qiu-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-150-逆波兰表达式求值"><a href="#Leetcode-150-逆波兰表达式求值" class="headerlink" title="Leetcode:150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">Leetcode:150. 逆波兰表达式求值</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用栈解决，需要注意数字先进后出问题</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">class Solution {    public int evalRPN(String[] tokens) {        if (tokens == null || tokens.length == 0){            return 0;        }        Stack<Integer> stack = new Stack<>();        int num1 = 0;        int num2 = 0;        for(String token: tokens){            if (token.equals("+") || token.equals("-") || token.equals("*") || token.equals("/")){                num1 = stack.pop();                num2 = stack.pop();                switch(token){                    case "+":                        stack.push(num1 + num2);                        break;                    case "-":                        stack.push(num2 - num1);                        break;                    case "*":                        stack.push(num2 * num1);                        break;                    case "/":                        stack.push(num2 / num1);                }            } else {                stack.push(Integer.valueOf(token));            }        }        return stack.pop();    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:341. 扁平化嵌套列表迭代器</title>
      <link href="/2020/04/05/leetcode-341-bian-ping-hua-qian-tao-lie-biao-die-dai-qi/"/>
      <url>/2020/04/05/leetcode-341-bian-ping-hua-qian-tao-lie-biao-die-dai-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-341-扁平化嵌套列表迭代器"><a href="#Leetcode-341-扁平化嵌套列表迭代器" class="headerlink" title="Leetcode:341. 扁平化嵌套列表迭代器"></a><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">Leetcode:341. 扁平化嵌套列表迭代器</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [[1,1],2,[1,1]]输出: [1,1,2,1,1]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [1,[4,[6]]]输出: [1,4,6]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用深度优先遍历获取递归的数字</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger { * *     // @return true if this NestedInteger holds a single integer, rather than a nested list. *     public boolean isInteger(); * *     // @return the single integer that this NestedInteger holds, if it holds a single integer *     // Return null if this NestedInteger holds a nested list *     public Integer getInteger(); * *     // @return the nested list that this NestedInteger holds, if it holds a nested list *     // Return null if this NestedInteger holds a single integer *     public List<NestedInteger> getList(); * } */public class NestedIterator implements Iterator<Integer> {    Queue<Integer> queue;    public NestedIterator(List<NestedInteger> nestedList) {        queue = new LinkedList<Integer>();        for(NestedInteger node: nestedList){            DFS(node);        }    }    @Override    public Integer next() {        return queue.poll();    }    @Override    public boolean hasNext() {        return !queue.isEmpty();    }    private void DFS(NestedInteger node){        if (node.isInteger()){            queue.offer(node.getInteger());        } else {            for(NestedInteger sonNode: node.getList()){                DFS(sonNode);            }        }    }}/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i = new NestedIterator(nestedList); * while (i.hasNext()) v[f()] = i.next(); */</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$,n为元素个数</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:227. 基本计算器 II</title>
      <link href="/2020/04/04/leetcode-227-ji-ben-ji-suan-qi-ii/"/>
      <url>/2020/04/04/leetcode-227-ji-ben-ji-suan-qi-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-227-基本计算器-II"><a href="#Leetcode-227-基本计算器-II" class="headerlink" title="Leetcode 227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">Leetcode 227. 基本计算器 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: &quot;3+2*2&quot;输出: 7</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: &quot; 3/2 &quot;输出: 1</code></pre><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><pre><code>输入: &quot; 3+5 / 2 &quot;输出: 5</code></pre><p>说明：<br>    你可以假设所给定的表达式都是有效的。<br>    请不要使用内置的库函数 eval。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：栈"><a href="#思路1：栈" class="headerlink" title="思路1：栈"></a>思路1：栈</h3><p>使用一个栈存储数字，然后使用一个符号记录延后记录运算符，初始为+，最后出栈相加即可得到最后的结果</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int calculate(String s) {        if (s == null || s.length() == 0){            return 0;        }        int result = 0;        int tempNum = 0;        char tempOp = '+';        int getNum = 0;        Stack<Integer> stack = new Stack<>();        for(int i = 0; i < s.length(); i++){            char ch = s.charAt(i);            if (ch >= '0' && ch <= '9'){                tempNum = tempNum * 10 + ch - '0';            }             if ((ch != ' ' && (ch < '0' || ch  > '9')) || i == s.length() - 1){                switch(tempOp){                    case '+':                        stack.push(tempNum);                        break;                    case '-':                        stack.push(-tempNum);                        break;                    case '*':                        getNum = stack.peek() * tempNum;                        stack.pop();                        stack.push(getNum);                        break;                    case '/':                        getNum = stack.peek() / tempNum;                        stack.pop();                        stack.push(getNum);                        break;                }                tempNum = 0;                tempOp = ch;            }        }        while(!stack.isEmpty()){            result += stack.pop();        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:239. 滑动窗口最大值</title>
      <link href="/2020/04/03/leetcode-239-hua-dong-chuang-kou-zui-da-zhi/"/>
      <url>/2020/04/03/leetcode-239-hua-dong-chuang-kou-zui-da-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-239-滑动窗口最大值"><a href="#Leetcode-239-滑动窗口最大值" class="headerlink" title="Leetcode: 239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Leetcode: 239. 滑动窗口最大值</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。进阶：你能在线性时间复杂度内解决此题吗？</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       31 [3  -1  -3] 5  3  6  7       31  3 [-1  -3  5] 3  6  7       51  3  -1 [-3  5  3] 6  7       51  3  -1  -3 [5  3  6] 7       61  3  -1  -3  5 [3  6  7]      7</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><pre><code>1 &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^41 &lt;= k &lt;= nums.length</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：优先级队列"><a href="#思路1：优先级队列" class="headerlink" title="思路1：优先级队列"></a>思路1：优先级队列</h3><p>使用优先级队列存储一个k的最大堆，大于k时每次去除前面的第k个元素</p><h3 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h3><p>将原数组设置为k个一个单元，然后分别求从左至当前位置的最大值（不超过k单元内）和从右至左，这样可以直接求两个边界最大值即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums == null || nums.length == 0){            return nums;        }        PriorityQueue<Integer> pq = new  PriorityQueue<Integer>(Collections.reverseOrder());        int[] result = new int[nums.length - k + 1];        for(int i = 0; i < nums.length; i++){            if (i >= k) pq.remove(nums[i - k]);            pq.offer(nums[i]);            if (i + 1 >= k) result[i + 1 - k] = pq.peek();        }        return result;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums == null || nums.length == 0){            return nums;        }        int n = nums.length;        int[] leftDPs = new int[n];        int[] rightDPs = new int[n];        leftDPs[0] = nums[0];        rightDPs[n - 1] = nums[n - 1];        int[] result = new int[n - k + 1];        for(int i = 1; i < n; i++){            if (i % k != 0){                leftDPs[i] = Math.max(nums[i], leftDPs[i - 1]);            } else {                leftDPs[i] = nums[i];            }            int rightIndex = n - i - 1;            if (rightIndex % k != 0){                rightDPs[rightIndex] = Math.max(nums[rightIndex], rightDPs[rightIndex + 1]);            }else {                rightDPs[rightIndex] = nums[rightIndex];            }        }        for(int i = 0; i < n - k + 1; i++){            result[i] = Math.max(rightDPs[i], leftDPs[i + k - 1]);        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(nlogk)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> 优先级队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:347. 前 K 个高频元素</title>
      <link href="/2020/04/01/leetcode-347-qian-k-ge-gao-pin-yuan-su/"/>
      <url>/2020/04/01/leetcode-347-qian-k-ge-gao-pin-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-347-前-K-个高频元素"><a href="#Leetcode-347-前-K-个高频元素" class="headerlink" title="Leetcode:347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Leetcode:347. 前 K 个高频元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: nums = [1], k = 1输出: [1]</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>维护一个大小为K的最小堆，根据数字出现次数排序</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用桶排序，维护一个出现次数的二维数组</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<Integer> topKFrequent(int[] nums, int k) {        Map<Integer, Integer> map = new HashMap<Integer, Integer>();        for(int num: nums){            if (!map.containsKey(num)){                map.put(num, 1);            } else{                map.put(num, map.get(num) + 1);            }        }        PriorityQueue<Integer> pq =                new PriorityQueue<Integer>((n1, n2) -> map.get(n1) - map.get(n2));        for(int num: map.keySet()){            pq.add(num);            if (pq.size() > k){                pq.poll();            }        }        List<Integer> maxQueue = new ArrayList<>();        while (pq.size() != 0){            maxQueue.add(pq.poll());        }        Collections.reverse(maxQueue);        return maxQueue;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<Integer> topKFrequent(int[] nums, int k) {        Map<Integer, Integer> map = new HashMap<Integer, Integer>();        for(int num: nums){            if (!map.containsKey(num)){                map.put(num, 1);            } else{                map.put(num, map.get(num) + 1);            }        }        List<Integer>[] sizeCount = new List[nums.length];        for(int num: map.keySet()){            int getCount = map.get(num) - 1;            if (sizeCount[getCount] == null){                sizeCount[getCount] = new ArrayList<Integer>();            }            sizeCount[getCount].add(num);        }        List<Integer> maxQueue = new ArrayList<>();        for(int i = nums.length - 1; i >= 0 && maxQueue.size() < k; i--){            if (sizeCount[i] == null){                continue;            }else {                maxQueue.addAll(sizeCount[i]);            }        }        return maxQueue;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(nlogk)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路1时间复杂度-1"><a href="#思路1时间复杂度-1" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:378. 有序矩阵中第K小的元素</title>
      <link href="/2020/03/31/leetcode-378-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/"/>
      <url>/2020/03/31/leetcode-378-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-378-有序矩阵中第K小的元素"><a href="#Leetcode-378-有序矩阵中第K小的元素" class="headerlink" title="Leetcode:378. 有序矩阵中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">Leetcode:378. 有序矩阵中第K小的元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。请注意，它是排序后的第k小元素，而不是第k个元素。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>matrix = [[ 1,  5,  9],[10, 11, 13],[12, 13, 15]],k = 8,</code></pre><p>返回 13。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：二分法"><a href="#思路1：二分法" class="headerlink" title="思路1：二分法"></a>思路1：二分法</h3><p>使用两个哨兵分别记录最大值和最小值（可以取到第k个值的区间），然后计算中间值的大小，根据这个中间值计算第k个值在二分区间中的位置，或者是大于多少个矩阵中的值，若比k大则属于前半区间，若小于等于k则处于后半区间，等于由于可能中间值不是矩阵中的值所以不能直接返回</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int kthSmallest(int[][] matrix, int k) {        if (matrix == null || matrix.length == 0 || matrix[0].length == 0){            throw new RuntimeException("matrix is empty!");        }        int rowSize = matrix.length;        int colSize = matrix[0].length;        if (k > colSize * rowSize){            throw new RuntimeException("matrix is less than k!");        }        int left = matrix[0][0];        int right = matrix[matrix.length - 1][matrix[0].length - 1];        int count = -1;        while (left < right){            int mid = (left + right) / 2;            count = getCount(matrix, mid, rowSize, colSize);            if (count < k){                left = mid + 1;            }else{                right = mid;            }        }        return right;    }    private int getCount(int[][] matrix,int mid,int rowSize,int colSize){        int rowIndex = rowSize - 1;        int colIndex = 0;        int count = 0;        while (rowIndex >= 0 && colIndex < colSize){            if (matrix[rowIndex][colIndex] <= mid){                count += rowIndex + 1;                colIndex ++;            }else{                rowIndex --;            }        }        return count;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(nlogn * log (max -min))$log(max - min)是因为有中间值逼近的过程</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:295. 数据流的中位数</title>
      <link href="/2020/03/30/leetcode-295-shu-ju-liu-de-zhong-wei-shu/"/>
      <url>/2020/03/30/leetcode-295-shu-ju-liu-de-zhong-wei-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-295-数据流的中位数"><a href="#Leetcode-295-数据流的中位数" class="headerlink" title="Leetcode:295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">Leetcode:295. 数据流的中位数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。例如，[2,3,4] 的中位数是 3[2,3] 的中位数是 (2 + 3) / 2 = 2.5设计一个支持以下两种操作的数据结构：void addNum(int num) - 从数据流中添加一个整数到数据结构中。double findMedian() - 返回目前所有元素的中位数。</code></pre><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2</code></pre><p>进阶:<br>    如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？<br>    如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：借用插入排序方法，每次插入后保持有序"><a href="#思路1：借用插入排序方法，每次插入后保持有序" class="headerlink" title="思路1：借用插入排序方法，每次插入后保持有序"></a>思路1：借用插入排序方法，每次插入后保持有序</h3><p>使用插入排序思路，每次插入新的数据后数据保持有序，这样时间复杂度主要来自于插入的O(n)<br>// TODO:其他思路</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1：插入排序思路"><a href="#代码1：插入排序思路" class="headerlink" title="代码1：插入排序思路"></a>代码1：插入排序思路</h3><pre class=" language-Java"><code class="language-Java">class MedianFinder {    private List<Integer> list;    /** initialize your data structure here. */    public MedianFinder() {        list = new ArrayList<>();    }    public void addNum(int num) {        if (list.isEmpty()){            list.add(num);            return;        }        int insertIndex = 0;        for(; insertIndex < list.size(); insertIndex++){            if(list.get(insertIndex) > num){                break;            }        }        list.add(insertIndex, num);    }    public double findMedian() {        if (list.size() % 2 != 0){            return list.get(list.size() / 2);        } else {            return 1.0 * (list.get(list.size() / 2 - 1) + list.get(list.size() / 2)) / 2;        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="代码1时间复杂度"><a href="#代码1时间复杂度" class="headerlink" title="代码1时间复杂度"></a>代码1时间复杂度</h3><p>主要是插入排序的时间每次为O(n)</p><h3 id="代码1空间复杂度"><a href="#代码1空间复杂度" class="headerlink" title="代码1空间复杂度"></a>代码1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:215. 数组中的第K个最大元素</title>
      <link href="/2020/03/29/leetcode-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su/"/>
      <url>/2020/03/29/leetcode-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [3,2,1,5,6,4] 和 k = 2输出: 5</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>采用快排的获取主元排序索引，更新到符合K大的位置</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int findKthLargest(int[] nums, int k) {        if (nums == null || nums.length < k){            return -1;        }        int result = -1;        int start = 0;        int end = nums.length - 1;        result = getIndex(nums, start, end);        while (result != k - 1){            if (result > k - 1){                end = result;                result = getIndex(nums, start, end - 1);            } else if(result < k - 1){                start = result;                result = getIndex(nums, start + 1, end);            }        }        if (result == k - 1){            return nums[k - 1];        }else {            return -1;        }    }    private int getIndex(int[] nums, int s, int e){        int getNum = nums[s];        int getIndex = s;        swap(nums, s, e);        for(int i = s; i < e; i++){            if (nums[i] > getNum){                swap(nums, getIndex, i);                getIndex ++;            }        }        swap(nums, getIndex, e);        return getIndex;    }    private void swap(int[] nums, int i, int j){        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    }}</code></pre><p>// TODO:其他思路</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均$O(n)$,最坏$(n^2)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 快排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:155. 最小栈</title>
      <link href="/2020/03/28/leetcode-155-zui-xiao-zhan/"/>
      <url>/2020/03/28/leetcode-155-zui-xiao-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-155-最小栈"><a href="#Leetcode-155-最小栈" class="headerlink" title="Leetcode:155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">Leetcode:155. 最小栈</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>主要还是栈，只是在栈的基础上获取栈中最小值，所以可以直接构建一个辅助栈，每次入栈时都记录当前位置下栈的最小数，出栈时只需要一起出即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class MinStack {    /** initialize your data structure here. */    private Stack<Integer> stack;    private Stack<Integer> stackHelper;    public MinStack() {        stack = new Stack<>();        stackHelper = new Stack<>();    }    public void push(int x) {        stack.add(x);        if (stackHelper.isEmpty() || x < stackHelper.peek()){            stackHelper.add(x);        }else {            stackHelper.add(stackHelper.peek());        }    }    public void pop() {        if (!stack.isEmpty()){            stack.pop();            stackHelper.pop();        } else {            throw new RuntimeException("Stack is empty!");        }    }    public int top() {        if (!stack.isEmpty()){            return stack.peek();        } else {            throw new RuntimeException("Stack is empty!");        }    }    public int getMin() {        if (!stackHelper.isEmpty()){            return stackHelper.peek();        } else {            throw new RuntimeException("Stack is empty!");        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(1)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:238. 除自身以外数组的乘积</title>
      <link href="/2020/03/28/leetcode-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/"/>
      <url>/2020/03/28/leetcode-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-238-除自身以外数组的乘积"><a href="#Leetcode-238-除自身以外数组的乘积" class="headerlink" title="Leetcode: 238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">Leetcode: 238. 除自身以外数组的乘积</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: [1,2,3,4]输出: [24,12,8,6]提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</code></pre><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h3><p>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：分别进行左右乘法"><a href="#思路1：分别进行左右乘法" class="headerlink" title="思路1：分别进行左右乘法"></a>思路1：分别进行左右乘法</h3><p>对所有位置的结果分为左边乘和右边乘，使用一个临时变量记录左乘(右乘)积，带入到相应位置，详情见代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] productExceptSelf(int[] nums) {        int[] result = new int[nums.length];        for(int i = 0; i < result.length; i++){            result[i] = 1;        }        int tempResult = 1;        for(int i = 0; i < result.length - 1; i++){            tempResult *= nums[i];            result[i+1] *= tempResult;        }        tempResult = 1;        for(int i = result.length - 1; i > 0; i--){            tempResult *= nums[i];            result[i - 1] *= tempResult;        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(N)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$除去结果空间以外</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:334. 递增的三元子序列</title>
      <link href="/2020/03/27/leetcode-334-di-zeng-de-san-yuan-zi-xu-lie/"/>
      <url>/2020/03/27/leetcode-334-di-zeng-de-san-yuan-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">334. 递增的三元子序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。数学表达式如下:如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [1,2,3,4,5]输出: true</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [5,4,3,2,1]输出: false</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：DP"><a href="#思路1：DP" class="headerlink" title="思路1：DP"></a>思路1：DP</h3><p>使用状态方程记录数组每个位置的最大递增序列大小，状态转移方程为$dps[i] = max(dps[i], dps[j] + 1 if nums[j] &lt; nums[i]) j \isin [0, i)</p><h3 id="思路2：加入两个哨兵元素"><a href="#思路2：加入两个哨兵元素" class="headerlink" title="思路2：加入两个哨兵元素"></a>思路2：加入两个哨兵元素</h3><p>使用两个哨兵元素记录值，即记录两个最小的数</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean increasingTriplet(int[] nums) {        if (nums == null || nums.length < 3){            return false;        }        int[] dps = new int[nums.length];        for(int i = 1; i < nums.length; i++){            for(int j = 0; j < i; j++){                if (nums[i] > nums[j]){                    dps[i] = Math.max(dps[i], dps[j] + 1);                    if (dps[i] == 2){                        return true;                    }                }            }        }        return false;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean increasingTriplet(int[] nums) {        if (nums == null || nums.length < 3){            return false;        }        int max1 = Integer.MAX_VALUE;        int max2 = Integer.MAX_VALUE;        for(int num: nums){            if (num <= max1){                max1 = num;            } else if (num <= max2){                max2 = num;            } else {                return true;            }        }        return false;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n^2)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> DP </tag>
            
            <tag> 数组 </tag>
            
            <tag> 哨兵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:350. 两个数组的交集 II</title>
      <link href="/2020/03/27/leetcode-350-liang-ge-shu-zu-de-jiao-ji-ii/"/>
      <url>/2020/03/27/leetcode-350-liang-ge-shu-zu-de-jiao-ji-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定两个数组，编写一个函数来计算它们的交集。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2]</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h3><pre><code>如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-两个数组排序后使用两个指针遍历比较"><a href="#思路1-两个数组排序后使用两个指针遍历比较" class="headerlink" title="思路1: 两个数组排序后使用两个指针遍历比较"></a>思路1: 两个数组排序后使用两个指针遍历比较</h3><p>对两个数组分别排序，然后使用一个哨兵分别计数，若两位置相等则加入，否则按照排序递增</p><h3 id="思路2-使用Hash计数"><a href="#思路2-使用Hash计数" class="headerlink" title="思路2: 使用Hash计数"></a>思路2: 使用Hash计数</h3><p>对一个数组hash计数，然后使用另外一个等相等加入</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] intersect(int[] nums1, int[] nums2) {        List<Integer> result = new ArrayList<>();        Arrays.sort(nums1);        Arrays.sort(nums2);        int aIndex = 0;        int bIndex = 0;        while(aIndex < nums1.length && bIndex < nums2.length){            if (nums1[aIndex] == nums2[bIndex]){                result.add(nums1[aIndex]);                aIndex ++;                bIndex ++;            } else if(nums1[aIndex] < nums2[bIndex]){                aIndex ++;            } else {                bIndex ++;            }        }        int[] intResult = new int[result.size()];        for(int i = 0; i < result.size(); i++){            intResult[i] = result.get(i);        }        return intResult;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] intersect(int[] nums1, int[] nums2) {        List<Integer> result = new ArrayList<>();        Map<Integer, Integer> hashMap = new HashMap<>();        for(int num: nums1){            if (!hashMap.containsKey(num)){                hashMap.put(num, 0);            }            hashMap.put(num, hashMap.get(num) + 1);        }        for(int num: nums2){            if (hashMap.containsKey(num) && hashMap.get(num) > 0){                result.add(num);                hashMap.put(num, hashMap.get(num) - 1);            }        }        int[] intResult = new int[result.size()];        for(int i = 0; i < result.size(); i++){            intResult[i] = result.get(i);        }        return intResult;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(nlog(n))$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路1时间复杂度-1"><a href="#思路1时间复杂度-1" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度-1"><a href="#思路1空间复杂度-1" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 排序 </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:384.打乱数组</title>
      <link href="/2020/03/27/leetcode-384-da-luan-shu-zu/"/>
      <url>/2020/03/27/leetcode-384-da-luan-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-384-打乱数组"><a href="#Leetcode-384-打乱数组" class="headerlink" title="Leetcode: 384.打乱数组"></a><a href="https://leetcode-cn.com/problems/shuffle-an-array/" target="_blank" rel="noopener">Leetcode: 384.打乱数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>打乱一个没有重复元素的数组。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>// 以数字集合 1, 2 和 3 初始化数组。int[] nums = {1,2,3};Solution solution = new Solution(nums);// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。solution.shuffle();// 重设数组到它的初始状态[1,2,3]。solution.reset();// 随机返回数组[1,2,3]打乱后的结果。solution.shuffle();</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：复制数组-移除"><a href="#思路1：复制数组-移除" class="headerlink" title="思路1：复制数组+移除"></a>思路1：复制数组+移除</h3><p>复制一个新数组，然后随机置入数组，将置入数组的数移除</p><h3 id="思路2：Fisher–Yates-shuffle"><a href="#思路2：Fisher–Yates-shuffle" class="headerlink" title="思路2：Fisher–Yates shuffle"></a>思路2：Fisher–Yates shuffle</h3><p>遍历数组，随机化得到一个从当前位置到最后位置的数进行交换，该方法产生n!种可能，但是如果采用随机产生两个随机数则是错的，其产生的可能性为$n^n$,简单证明为n!可能不能被$n^n$整除</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1-复制数组-移除"><a href="#代码1-复制数组-移除" class="headerlink" title="代码1: 复制数组+移除"></a>代码1: 复制数组+移除</h3><pre class=" language-Java"><code class="language-Java">class Solution {    private int[] nums;    private int[] origins;    private Random rand = new Random();    public Solution(int[] nums) {        this.nums = nums;        origins = this.nums.clone();    }    /** Resets the array to its original configuration and return it. */    public int[] reset() {        this.nums = this.origins;        this.origins = this.origins.clone();        return this.nums;    }    /** Returns a random shuffling of the array. */    public int[] shuffle() {        List<Integer> copyList = new ArrayList<>();        for(int num: this.nums){            copyList.add(num);        }        for(int i = 0; i < this.nums.length; i++){            int removeIndex = rand.nextInt(copyList.size());            this.nums[i] = copyList.get(removeIndex);            copyList.remove(removeIndex);        }        return this.nums;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    private int[] nums;    private int[] origins;    private Random rand = new Random();    public Solution(int[] nums) {        this.nums = nums;        origins = this.nums.clone();    }    /** Resets the array to its original configuration and return it. */    public int[] reset() {        this.nums = this.origins;        this.origins = this.origins.clone();        return this.nums;    }    /** Returns a random shuffling of the array. */    public int[] shuffle() {        for(int i = 0; i < this.nums.length; i++){            int swapIndex = rand.nextInt(this.nums.length - i) + i;            int temp = this.nums[i];            this.nums[i] = this.nums[swapIndex];            this.nums[swapIndex] = temp;        }        return this.nums;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n^2)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$没有了移除操作</p><h3 id="思路1空间复杂度-1"><a href="#思路1空间复杂度-1" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 数组 </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:283. 移动零</title>
      <link href="/2020/03/26/leetcode-283-yi-dong-ling/"/>
      <url>/2020/03/26/leetcode-283-yi-dong-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-283-移动零"><a href="#Leetcode-283-移动零" class="headerlink" title="Leetcode:283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">Leetcode:283. 移动零</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-直接使用非零计数"><a href="#思路1-直接使用非零计数" class="headerlink" title="思路1: 直接使用非零计数"></a>思路1: 直接使用非零计数</h3><p>直接使用遍历加非零计数进行替换操作，然后对最后为零的填零</p><h3 id="思路2-非零计数-替换"><a href="#思路2-非零计数-替换" class="headerlink" title="思路2: 非零计数+替换"></a>思路2: 非零计数+替换</h3><p>思路1方法若在大量零的情况下需要遍历两次，所以可以考虑使用两个指针交换数据</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public void moveZeroes(int[] nums) {        if (nums == null || nums.length == 0){            return;        }        int notZeroIndex = 0;        for(int i = 0; i < nums.length; i++){            if (nums[i] != 0){                nums[notZeroIndex++] = nums[i];            }        }        for(int i = notZeroIndex; i < nums.length; i++){            nums[i] = 0;        }    }}</code></pre><h3 id="代码2：双指针-交换"><a href="#代码2：双指针-交换" class="headerlink" title="代码2：双指针+交换"></a>代码2：双指针+交换</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public void moveZeroes(int[] nums) {        if (nums == null || nums.length == 0){            return;        }        int notZeroIndex = 0;        for(int i = 0; i < nums.length; i++){            if(nums[i] != 0){                swap(nums, i, notZeroIndex++);            }        }    }    private void swap(int[] nums, int i, int j){        if (i == j){            return;        }        nums[i] = nums[i] + nums[j];        nums[j] = nums[i] - nums[j];        nums[i] = nums[i] - nums[j];    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1：直接使用非零计数"><a href="#思路1：直接使用非零计数" class="headerlink" title="思路1：直接使用非零计数"></a>思路1：直接使用非零计数</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>同上，但是时间复杂度在最坏情况下要比思路1优</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:217. 存在重复元素</title>
      <link href="/2020/03/26/leetcode-217-cun-zai-chong-fu-yuan-su/"/>
      <url>/2020/03/26/leetcode-217-cun-zai-chong-fu-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-217-存在重复元素"><a href="#Leetcode-217-存在重复元素" class="headerlink" title="Leetcode:217. 存在重复元素"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">Leetcode:217. 存在重复元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [1,2,3,1]输出: true</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [1,2,3,4]输出: false</code></pre><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><pre><code>输入: [1,1,1,3,3,4,3,2,4,2]输出: true</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-直接使用Hash"><a href="#思路1-直接使用Hash" class="headerlink" title="思路1: 直接使用Hash"></a>思路1: 直接使用Hash</h3><p>使用hashset对数据计数，若重复出现则直接返回true</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>###　代码１：直接使用Hash</p><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean containsDuplicate(int[] nums) {        if (nums == null || nums.length == 0){            return false;        }        Set<Integer> set = new HashSet<>();        for(int num: nums){            if (set.contains(num)){                return true;            } else{                set.add(num);            }        }        return false;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:189. 旋转数组</title>
      <link href="/2020/03/25/leetcode-189-xuan-zhuan-shu-zu/"/>
      <url>/2020/03/25/leetcode-189-xuan-zhuan-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-189-旋转数组"><a href="#Leetcode-189-旋转数组" class="headerlink" title="Leetcode:189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">Leetcode:189. 旋转数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-三次反转数组"><a href="#思路1-三次反转数组" class="headerlink" title="思路1: 三次反转数组"></a>思路1: 三次反转数组</h3><p>可以看作是首先将整个数组旋转，然后前k个元素反转，后nums.length - k个元素反转</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1-三次反转数组"><a href="#代码1-三次反转数组" class="headerlink" title="代码1: 三次反转数组"></a>代码1: 三次反转数组</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public void rotate(int[] nums, int k){        k = k % nums.length;        if (k == 0){            return;        }        reverse(nums, 0, nums.length - 1);        reverse(nums, 0, k-1);        reverse(nums, k, nums.length - 1);    }    private void reverse(int[] nums, int startIndex, int endIndex){        while(startIndex < endIndex){            int temp = nums[startIndex];            nums[startIndex++] = nums[endIndex];            nums[endIndex--] = temp;        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
            <tag> 反转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:152. 乘积最大子数组</title>
      <link href="/2020/03/24/leetcode-152-cheng-ji-zui-da-zi-shu-zu/"/>
      <url>/2020/03/24/leetcode-152-cheng-ji-zui-da-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以维护两个DP,表示最大值和最小值（因为数据中包含正负),转移方程为$maxDP[i+1] = max(nums[i+1], maxDP[i+1]<em>nums[i+1], minDP[i+1]</em>nums[i+1])$以及$minDP[i+1] = min(nums[i+1], maxDP[i+1]<em>nums[i+1], minDP[i+1]</em>nums[i+1])$,由于只涉及DP的两个状态值，所以去除掉所有状态的存储，只存储上一状态即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">class Solution {    public int maxProduct(int[] nums) {        int result = nums[0];        int maxNum = 1;        int minNum = 1;        for(int i = 0; i < nums.length; i++){            if (nums[i] < 0){                maxNum = maxNum + minNum;                minNum = maxNum - minNum;                maxNum = maxNum - minNum;            }            maxNum = nums[i] > maxNum * nums[i] ? nums[i]: maxNum * nums[i];            minNum = nums[i] < minNum * nums[i] ? nums[i]: minNum * nums[i];            if(result < maxNum){                result = maxNum;            }        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以使用多个DP过程存储中间可能状态</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:344. 反转字符串</title>
      <link href="/2020/03/24/leetcode-344-fan-zhuan-zi-fu-chuan/"/>
      <url>/2020/03/24/leetcode-344-fan-zhuan-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-344-反转字符串"><a href="#Leetcode-344-反转字符串" class="headerlink" title="Leetcode:344. 反转字符串"></a><a href="https://leetcode-cn.com/explore/interview/card/top-interview-quesitons/275/string/1144/" target="_blank" rel="noopener">Leetcode:344. 反转字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接使用前后指针swap</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">class Solution {    public void reverseString(char[] s) {        if(s == null || s.length == 0){            return;        }        int left = 0;        int right = s.length - 1;        while (left < right){            char temp = s[left];            s[left++] = s[right];            s[right--] = temp;        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:387. 字符串中的第一个唯一字符</title>
      <link href="/2020/03/23/leetcode-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu/"/>
      <url>/2020/03/23/leetcode-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-387-字符串中的第一个唯一字符"><a href="#Leetcode-387-字符串中的第一个唯一字符" class="headerlink" title="Leetcode:387. 字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">Leetcode:387. 字符串中的第一个唯一字符</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h3><pre><code>s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2.注意事项：您可以假定该字符串只包含小写字母。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路：数组-字典"><a href="#思路：数组-字典" class="headerlink" title="思路：数组 字典"></a>思路：数组 字典</h3><p>直接使用数组对字母计数二次遍历</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int firstUniqChar(String s) {        if (s == null || s.length() == 0){            return -1;        }        int[] chDict = new int[26];        for(int i = 0; i < s.length(); i++){            chDict[s.charAt(i) - 'a'] += 1;        }        for(int i = 0; i < s.length(); i++){            if(chDict[s.charAt(i) - 'a'] == 1){                return i;            }        }        return -1;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:242. 有效的字母异位词</title>
      <link href="/2020/03/22/leetcode-242-you-xiao-de-zi-mu-yi-wei-ci/"/>
      <url>/2020/03/22/leetcode-242-you-xiao-de-zi-mu-yi-wei-ci/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-242-有效的字母异位词"><a href="#Leetcode-242-有效的字母异位词" class="headerlink" title="Leetcode:242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">Leetcode:242. 有效的字母异位词</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true示例 2:输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false说明:你可以假设字符串只包含小写字母。</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h3><pre><code>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-哈希表"><a href="#思路1-哈希表" class="headerlink" title="思路1: 哈希表"></a>思路1: 哈希表</h3><p>直接使用哈希表计数，先计算s的每个字母个数相加，然后计算t中个数相减</p><h3 id="思路2：数组-计数"><a href="#思路2：数组-计数" class="headerlink" title="思路2：数组+计数"></a>思路2：数组+计数</h3><p>鉴于只有26个字母，所以可以只用一个数组计数，解法可同上，但是常数空间消耗更少</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1：哈希表"><a href="#代码1：哈希表" class="headerlink" title="代码1：哈希表"></a>代码1：哈希表</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean isAnagram(String s, String t) {        if ((s == null && t != null) || (s != null && t == null) || s.length() != t.length()) {            return false;        }        Map<Character, Integer> chMap = new HashMap<>();        for(char ch: s.toCharArray()){            if (!chMap.containsKey(ch)){                chMap.put(ch, 1);            }            chMap.put(ch, chMap.get(ch) + 1);        }        for(char ch: t.toCharArray()){            if(!chMap.containsKey(ch) || chMap.get(ch) != 0){                return false;            } else{                chMap.put(ch, chMap.get(ch) - 1);            }        }        return true;    }}</code></pre><h3 id="代码2：数组-计数"><a href="#代码2：数组-计数" class="headerlink" title="代码2：数组+计数"></a>代码2：数组+计数</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean isAnagram(String s, String t) {        if ((s == null && t != null) || (s != null && t == null) || s.length() != t.length()) {            return false;        }        int[] count = new int[26];        for(int i=0; i < s.length(); i++){            count[s.charAt(i) - 'a'] += 1;            count[t.charAt(i) - 'a'] -= 1;        }        for(int i=0; i < 26; i++){            if(count[i] != 0){                return false;            }        }        return true;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>n</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>1,常数</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> easy </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 212: 单词搜索II</title>
      <link href="/2020/03/21/leetcode-212-dan-ci-sou-suo-ii/"/>
      <url>/2020/03/21/leetcode-212-dan-ci-sou-suo-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-212-单词搜索II"><a href="#Leetcode-212-单词搜索II" class="headerlink" title="Leetcode 212: 单词搜索II"></a><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">Leetcode 212: 单词搜索II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[[&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],[&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],[&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],[&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]]输出: [&quot;eat&quot;,&quot;oath&quot;]说明:你可以假设所有输入都由小写字母 a-z 组成。</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h3><pre><code>你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-回溯-DFS"><a href="#思路1-回溯-DFS" class="headerlink" title="思路1: 回溯+DFS"></a>思路1: 回溯+DFS</h3><p>直接使用回溯+DFS判断每个单词是否存在，需要注意一个单词不能使用两次以上一个字符。</p><h3 id="思路2-前缀树-回溯减枝"><a href="#思路2-前缀树-回溯减枝" class="headerlink" title="思路2: 前缀树+回溯减枝"></a>思路2: 前缀树+回溯减枝</h3><p>对所有的单词建立节点，然后回溯board中每个可能的单词，裁剪掉不能满足前缀树的路径</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1-回溯-DFS"><a href="#代码1-回溯-DFS" class="headerlink" title="代码1: 回溯+DFS"></a>代码1: 回溯+DFS</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public List<String> findWords(char[][] board, String[] words) {        List<String> result = new LinkedList<>();        if (words.length == 0 || board.length == 0 || board[0].length == 0){            return result;        }        for(String word: words){            if(hasWord(word, board)) {                result.add(word);            }        }        return result;    }    private boolean hasWord(String s, char[][] board){        boolean canFind = false;        for(int i = 0; i < board.length; i++){            for(int j = 0; j < board[0].length; j++){                if (s.charAt(0) == board[i][j] && wordDFS(s, board, 0, i, j)) {                    canFind = true;                    break;                }            }            if (canFind){                break;            }        }        return canFind;    }    private boolean wordDFS(String s, char[][] board, int startIndex, int i, int j){        if (startIndex == s.length() - 1){            return true;        }        boolean canFind = false;        char temp = s.charAt(startIndex);        char getCh = s.charAt(startIndex + 1);        board[i][j] = '$';        if(canGetCh(getCh, board, i + 1, j)){            canFind = canFind || wordDFS(s, board, startIndex+1, i+1, j);            if (canFind){                board[i][j] = temp;            }        }        if (!canFind && canGetCh(getCh, board, i -1, j)){            canFind = canFind || wordDFS(s, board, startIndex+1, i-1, j);            if (canFind){                board[i][j] = temp;            }        }        if (!canFind && canGetCh(getCh, board, i, j+1)){            canFind = canFind || wordDFS(s, board, startIndex+1, i, j+1);            if (canFind){                board[i][j] = temp;            }        }        if (!canFind && canGetCh(getCh, board, i, j-1)){            canFind = canFind || wordDFS(s, board, startIndex+1, i, j-1);            if (canFind){                board[i][j] = temp;            }        }        board[i][j] = temp;        return canFind;    }    private boolean canGetCh(char getCh, char[][] board, int i, int j){        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length){            return false;        }        return board[i][j] == getCh;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1-时间复杂度"><a href="#思路1-时间复杂度" class="headerlink" title="思路1:时间复杂度"></a>思路1:时间复杂度</h3><p>只超过14%</p><h3 id="思路2-空间复杂度"><a href="#思路2-空间复杂度" class="headerlink" title="思路2:空间复杂度"></a>思路2:空间复杂度</h3><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 前缀树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 208:实现Trie(前缀树)</title>
      <link href="/2020/03/20/leetcode-208-shi-xian-trie-qian-zhui-shu/"/>
      <url>/2020/03/20/leetcode-208-shi-xian-trie-qian-zhui-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-208-实现Trie-前缀树"><a href="#Leetcode-208-实现Trie-前缀树" class="headerlink" title="Leetcode 208:实现Trie(前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">Leetcode 208:实现Trie(前缀树)</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;);   // 返回 truetrie.search(&quot;app&quot;);     // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;);   trie.search(&quot;app&quot;);     // 返回 true</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>你可以假设所有的输入都是由小写字母 a-z 构成的。保证所有输入均为非空字符串。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-前缀树基本实现"><a href="#思路1-前缀树基本实现" class="headerlink" title="思路1: 前缀树基本实现"></a>思路1: 前缀树基本实现</h3><p>主要是使用前缀树的基本概念，将前缀字母连接到下一个后缀节点,以及标记好结束节点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><pre class=" language-Java"><code class="language-Java">class Trie {    private final int alphaSize = 26;    private Trie[] children = new Trie[alphaSize];    private boolean isEnd = false;    /** Initialize your data structure here. */    public Trie() {    }    /** Inserts a word into the trie. */    public void insert(String word) {        Trie temp = this;        for(var ch: word.toCharArray()){            if (temp.children[ch - 'a'] == null){                temp.children[ch - 'a'] = new Trie();            }            temp = temp.children[ch - 'a'];        }        temp.isEnd=true;    }    /** Returns if the word is in the trie. */    public boolean search(String word) {        Trie temp = this;        for(var ch: word.toCharArray()){            if (temp.children[ch - 'a'] == null){                return false;            }            temp = temp.children[ch - 'a'];        }        return temp.isEnd;    }    /** Returns if there is any word in the trie that starts with the given prefix. */    public boolean startsWith(String prefix) {        Trie temp = this;        for(var ch: prefix.toCharArray()){            if (temp.children[ch - 'a'] == null){                return false;            }            temp = temp.children[ch - 'a'];        }        return true;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$n$均可看作是链表的查找插入</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$n$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 140: 单词切分II</title>
      <link href="/2020/03/19/leetcode-140-dan-ci-qie-fen-ii/"/>
      <url>/2020/03/19/leetcode-140-dan-ci-qie-fen-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-140-单词切分II"><a href="#Leetcode-140-单词切分II" class="headerlink" title="Leetcode 140: 单词切分II"></a><a href="https://leetcode-cn.com/problems/word-break-ii/" target="_blank" rel="noopener">Leetcode 140: 单词切分II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>分隔时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]输出:[&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入:s = &quot;pineapplepenapple&quot;wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]输出:[&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]解释: 注意你可以重复使用字典中的单词。</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入:s = &quot;catsandog&quot;wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出:[]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：DP-回溯"><a href="#思路1：DP-回溯" class="headerlink" title="思路1：DP+回溯"></a>思路1：DP+回溯</h3><p>即利用中等难度的dp单词切分获取到可能的子序列，根据是否可以整体切分以及切分标记回溯这些字序列获取最终的结果</p><h3 id="思路2-记忆回溯"><a href="#思路2-记忆回溯" class="headerlink" title="思路2: 记忆回溯"></a>思路2: 记忆回溯</h3><p>将每个位置i记为以他为起点，到最后结果的可能切分，最后递归求解。将每个位置记为(i, list<str>),减少无用的后缀计算，以空间换时间</p><h3 id="思路3：DP-直接记录"><a href="#思路3：DP-直接记录" class="headerlink" title="思路3：DP+直接记录"></a>思路3：DP+直接记录</h3><p>将每个位置直接记录可能的前缀串，最后得到记录的全单词切分前缀串。但是在leetcode上会出现内存分配过大而超时的现象，故意需要增加判断是否可以完全完成单词切分</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1-DP-回溯"><a href="#代码1-DP-回溯" class="headerlink" title="代码1: DP+回溯"></a>代码1: DP+回溯</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<String> wordBreak(String s, List<String> wordDict) {        List<String> result = new LinkedList<>();        if (s == null || s.length() == 0 || wordDict.size() == 0){            return result;        }        Set<String> hashSet = new HashSet<>(wordDict);        boolean[] dps = new boolean[s.length() + 1];        dps[0] = true;        for(int end=1; end < s.length() + 1; end++){            for(int start=0; start < end; start++) {                if(dps[start] && hashSet.contains(s.substring(start, end))) {                    dps[end] = true;                    break;                }            }        }        if (!dps[s.length()]) {            return result;        }        List<String> temp = new LinkedList<>();        wordBreakHelper(s, hashSet, s.length(), dps, temp, result);        return result;    }    private void wordBreakHelper(String s, Set<String> hashSet, int endIndex, boolean[] dps, List<String> temp, List<String> result) {        if (endIndex == 0) {            StringBuilder sb = new StringBuilder();            for(int i = temp.size() - 1; i >= 0; i--){                if (i != temp.size() - 1) {                    sb.append(" ");                }                sb.append(temp.get(i));            }            result.add(sb.toString());        }        for(int i=endIndex - 1; i >= 0; i--) {            if (dps[i] && hashSet.contains(s.substring(i, endIndex))){                temp.add(s.substring(i, endIndex));                wordBreakHelper(s, hashSet, i, dps, temp, result);                temp.remove(temp.size() - 1);            }        }    }}</code></pre><h3 id="代码2-记忆回溯"><a href="#代码2-记忆回溯" class="headerlink" title="代码2: 记忆回溯"></a>代码2: 记忆回溯</h3><pre class=" language-Java"><code class="language-Java">public class Solution2 {    Map<Integer, List<String>> hashMap = new HashMap<>();    public List<String> wordBreak(String s, List<String> wordDict){        List<String> result = new LinkedList<>();        if (s == null || s.length() == 0 || wordDict.size() == 0){            return result;        }        return wordBreakHelper(s, new HashSet<>(wordDict), 0);    }    private List<String> wordBreakHelper(String s, Set<String> hashSet, int startIndex) {        if (hashMap.containsKey(startIndex)) {            return hashMap.get(startIndex);        }        List<String> temp = new LinkedList<>();        // 标记是否可以完全切分        if (startIndex == s.length()) {            temp.add("");        }        for(int end=startIndex+1; end <= s.length(); end++){            if(hashSet.contains(s.substring(startIndex, end))){                List<String> list = wordBreakHelper(s, hashSet, end);                for(var l: list){                    if (l.equals("")){                        temp.add(s.substring(startIndex, end));                    } else{                        temp.add(s.substring(startIndex, end) + " " + l);                    }                }            }        }        hashMap.put(startIndex, temp);        return temp;    }}</code></pre><h3 id="代码3-DP-直接记录"><a href="#代码3-DP-直接记录" class="headerlink" title="代码3: DP+直接记录"></a>代码3: DP+直接记录</h3><pre class=" language-Java"><code class="language-Java">public class Solution3 {    public List<String> wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0 || wordDict.size() == 0 || !canWordBreak(s, wordDict)){            return new LinkedList<String>();        }        Set<String> hashSet = new HashSet<>(wordDict);        List<String>[] dps = new LinkedList[s.length() + 1];        List<String> zero = new LinkedList<>();        zero.add("");        dps[0] = zero;        for(int end=1; end <= s.length(); end++){            List<String> temp = new LinkedList<>();            for(int start=0; start < end; start++){                if (dps[start].size() > 0 && hashSet.contains(s.substring(start, end))){                    for(var l: dps[start]){                        temp.add(l + (l.equals("") ? "" : " ") + s.substring(start, end));                    }                }            }            dps[end] = temp;        }        return dps[s.length()];    }    public boolean canWordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if(wordDict.size() == 0) {            return false;        }        Set<String> hashSet = new HashSet<>(wordDict);        boolean[] dps = new boolean[s.length() + 1];        dps[0] = true;        for(int end = 1; end < s.length() + 1; end++) {            for(int start=0; start < end; start++) {                if (dps[start] && hashSet.contains(s.substring(start, end))) {                    dps[end] = true;                    break;                }            }        }        return dps[s.length()];    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>相当于减枝之后$n^n$？</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$n$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$n^3$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$n^2$，相当于每次都清除</p><h3 id="思路3时间复杂度"><a href="#思路3时间复杂度" class="headerlink" title="思路3时间复杂度"></a>思路3时间复杂度</h3><p>$n^3$</p><h3 id="思路3空间复杂度"><a href="#思路3空间复杂度" class="headerlink" title="思路3空间复杂度"></a>思路3空间复杂度</h3><p>$n^3$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hard </tag>
            
            <tag> 回溯 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 139: 单词切分</title>
      <link href="/2020/03/19/leetcode-139-dan-ci-qie-fen/"/>
      <url>/2020/03/19/leetcode-139-dan-ci-qie-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-139-单词切分"><a href="#Leetcode-139-单词切分" class="headerlink" title="Leetcode 139: 单词切分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">Leetcode 139: 单词切分</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。    注意你可以重复使用字典中的单词。</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：暴力遍历（时间爆表）"><a href="#思路1：暴力遍历（时间爆表）" class="headerlink" title="思路1：暴力遍历（时间爆表）"></a>思路1：暴力遍历（时间爆表）</h3><p>检查每一个前缀的子字符串回溯实现</p><h3 id="思路2：记忆化可切分后缀"><a href="#思路2：记忆化可切分后缀" class="headerlink" title="思路2：记忆化可切分后缀"></a>思路2：记忆化可切分后缀</h3><p>记录一个回溯记忆数组，若该后缀可切分则综合到最后可切分，这样可以大幅减少调用函数次数</p><h3 id="思路3-BFS实现"><a href="#思路3-BFS实现" class="headerlink" title="思路3: BFS实现"></a>思路3: BFS实现</h3><p>使用广度优先遍历实现，相当于将可到达相同的前缀节点合并，不进行相同的后续操作，减少函数调用次数。</p><h3 id="思路4-DP实现"><a href="#思路4-DP实现" class="headerlink" title="思路4: DP实现"></a>思路4: DP实现</h3><p>第j个位置可根据可形成前缀的位置进行计算，若其前缀为i,则若s.sub(i, j)在字典中则第j个位置为可拼接，最后一个位置即为最后是否可切分结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public boolean wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if (wordDict.size() == 0) {            return false;        }        HashSet<String> hashSet = new HashSet<>(wordDict);        return wordBreakHelper(s, 0, hashSet);    }    private boolean wordBreakHelper(String s, int startIndex, HashSet<String> hashSet) {        if (startIndex >= s.length()) {            return true;        }        boolean hasMatch = false;        for(var neededStr: hashSet) {//            System.out.println(s.substring(startIndex, startIndex + neededStr.length()));            if (startIndex + neededStr.length() <= s.length() && s.substring(startIndex, startIndex + neededStr.length()).equalsIgnoreCase(neededStr)) {                hasMatch = hasMatch || wordBreakHelper(s, startIndex + neededStr.length(), hashSet);                if (hasMatch) {                    break;                }            }        }        return hasMatch;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">public class Solution2 {    public boolean wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if (wordDict.size() == 0) {            return false;        }        HashSet<String> hashSet = new HashSet<>(wordDict);        return wordBreakHelper(s, 0, hashSet, new Boolean[s.length()]);    }    private boolean wordBreakHelper(String neededStr, int startIndex, HashSet<String> hashSet, Boolean[] hasMatch) {        if (startIndex == neededStr.length()) {            return true;        }        if (hasMatch[startIndex] != null) {            return hasMatch[startIndex];        }        for(int i=startIndex + 1; i <= neededStr.length(); i++) {            if (hashSet.contains(neededStr.substring(startIndex, i)) && wordBreakHelper(neededStr, i, hashSet, hasMatch)) {                return hasMatch[startIndex] = true;            }        }        return hasMatch[startIndex] = false;    }}</code></pre><h3 id="代码3：BFS-（队列实现）"><a href="#代码3：BFS-（队列实现）" class="headerlink" title="代码3：BFS （队列实现）"></a>代码3：BFS （队列实现）</h3><pre class=" language-Java"><code class="language-Java">public class Solution3 {    public boolean wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if(wordDict.size() == 0) {            return false;        }        Set<String> hashSet = new HashSet<>(wordDict);        Queue<Integer> queue = new LinkedList<>();        boolean[] hasSeen = new boolean[s.length()];        queue.add(0);        while (!queue.isEmpty()) {            int startIndex = queue.remove();            if (!hasSeen[startIndex]) {                for(int endIndex = startIndex + 1; endIndex <= s.length(); endIndex++) {                    if (hashSet.contains(s.substring(startIndex, endIndex))) {                        queue.add(endIndex);                        if (endIndex == s.length()) {                            return true;                        }                    }                }                hasSeen[startIndex] = true;            }        }        return false;    }}</code></pre><h3 id="代码4-DP实现"><a href="#代码4-DP实现" class="headerlink" title="代码4: DP实现"></a>代码4: DP实现</h3><pre class=" language-Java"><code class="language-Java">public class Solution4 {    public boolean wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if(wordDict.size() == 0) {            return false;        }        Set<String> hashSet = new HashSet<>(wordDict);        boolean[] dps = new boolean[s.length() + 1];        dps[0] = true;        for(int end = 1; end < s.length() + 1; end++) {            for(int start=0; start < end; start++) {                if (dps[start] && hashSet.contains(s.substring(start, end))) {                    dps[end] = true;                    break;                }            }        }        return dps[s.length()];    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1：时间复杂度"><a href="#思路1：时间复杂度" class="headerlink" title="思路1：时间复杂度"></a>思路1：时间复杂度</h3><p>$n^n$</p><h3 id="思路1-空间复杂度"><a href="#思路1-空间复杂度" class="headerlink" title="思路1: 空间复杂度"></a>思路1: 空间复杂度</h3><p>$n$</p><h3 id="思路2-时间复杂度"><a href="#思路2-时间复杂度" class="headerlink" title="思路2: 时间复杂度"></a>思路2: 时间复杂度</h3><p>$n^2$</p><h3 id="思路2：空间复杂度"><a href="#思路2：空间复杂度" class="headerlink" title="思路2：空间复杂度"></a>思路2：空间复杂度</h3><p>$n$</p><h3 id="思路3-时间复杂度"><a href="#思路3-时间复杂度" class="headerlink" title="思路3: 时间复杂度"></a>思路3: 时间复杂度</h3><p>$n^2$</p><h3 id="思路3：空间复杂度"><a href="#思路3：空间复杂度" class="headerlink" title="思路3：空间复杂度"></a>思路3：空间复杂度</h3><p>$n$</p><h3 id="思路4-时间复杂度"><a href="#思路4-时间复杂度" class="headerlink" title="思路4: 时间复杂度"></a>思路4: 时间复杂度</h3><p>$n^2$</p><h3 id="思路4：空间复杂度"><a href="#思路4：空间复杂度" class="headerlink" title="思路4：空间复杂度"></a>思路4：空间复杂度</h3><p>$n$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>重点在于如何将重复或者非必需的步骤省略</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> BFS </tag>
            
            <tag> 回溯 </tag>
            
            <tag> DP </tag>
            
            <tag> 标记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 131: 分割回文串</title>
      <link href="/2020/03/17/leetcode-131-fen-ge-hui-wen-chuan/"/>
      <url>/2020/03/17/leetcode-131-fen-ge-hui-wen-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-131-分割回文串"><a href="#Leetcode-131-分割回文串" class="headerlink" title="Leetcode 131: 分割回文串"></a>Leetcode 131: 分割回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>输入: &quot;aab&quot;输出:[    [&quot;aa&quot;,&quot;b&quot;],    [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：-回溯-判断"><a href="#思路1：-回溯-判断" class="headerlink" title="思路1： 回溯+判断"></a>思路1： 回溯+判断</h3><p>即利用回溯思路不断增加是回文前缀字符串组的后续可能回文串</p><h3 id="思路1：代码"><a href="#思路1：代码" class="headerlink" title="思路1：代码"></a>思路1：代码</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<List<String>> partition(String s) {        List<List<String>> result = new LinkedList<>();        if (s.length() == 0) {            return result;        }        List<String> temp = new LinkedList<>();        partitionHelper(result, s, 0, temp);        return result;    }    private boolean canReverse(String s, int i, int j) {        if (i >= j) {            return true;        }        if (s.charAt(i++) == s.charAt(j--)) {            return canReverse(s, i, j);        } else {            return false;        }    }    private void partitionHelper(List<List<String>> res, String s, int startIndex, List<String> temp) {        int size = s.length();        if (size <= startIndex) {            res.add(new LinkedList<String>(temp));            return;        }        for(int i = startIndex; i < size; i++) {            if (canReverse(s, startIndex, i)) {                temp.add(s.substring(startIndex, i + 1));                partitionHelper(res, s, i + 1, temp);                temp.remove(temp.size() - 1);            }        }    }}</code></pre><h3 id="思路2：回溯-动态规划优化"><a href="#思路2：回溯-动态规划优化" class="headerlink" title="思路2：回溯+动态规划优化"></a>思路2：回溯+动态规划优化</h3><p>空间换时间，将判断是否是回文看成是一个动态规划，直接使用$n^2$算法求取，之后直接$1$调取</p><h3 id="思路2-代码"><a href="#思路2-代码" class="headerlink" title="思路2: 代码"></a>思路2: 代码</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public List<List<String>> partition(String s) {        List<List<String>> res = new LinkedList<List<String>>();        if (s.length() == 0) {            return res;        }        int size = s.length();        boolean[][] dps = new boolean[size][size];        for(int right = 0; right < size; right++) {            for(int left = 0; left <= right; left++) {                if (s.charAt(left) == s.charAt(right) && (right - left <= 2 || dps[left + 1][right - 1])) {                    dps[left][right] = true;                }            }        }        List<String> temp = new LinkedList<>();        partitionHelper(res, s, 0, temp, dps);        return res;    }    private void partitionHelper(List<List<String>> res, String s, int startIndex, List<String> temp, boolean[][] dps) {        int size = s.length();        if (startIndex >= size) {            res.add(new LinkedList<>(temp));            return;        }        for(int i = startIndex; i < size; i++) {            if (dps[startIndex][i]) {                temp.add(s.substring(startIndex, i + 1));                partitionHelper(res, s, i + 1, temp, dps);                temp.remove(temp.size() - 1);            }        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$n*2^n?$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$n*2^n?$</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$2^n + n^2$</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$n * 2^n + n^2$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Middle </tag>
            
            <tag> 回溯 </tag>
            
            <tag> DFS </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 25:验证回文串</title>
      <link href="/2020/03/12/leetcode-25-yan-zheng-hui-wen-chuan/"/>
      <url>/2020/03/12/leetcode-25-yan-zheng-hui-wen-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-25-验证回文串"><a href="#Leetcode-25-验证回文串" class="headerlink" title="Leetcode 25:验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">Leetcode 25:验证回文串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;输出: true</code></pre><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><pre><code>输入: &quot;race a car&quot;输出: false</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：双指针"><a href="#思路1：双指针" class="headerlink" title="思路1：双指针"></a>思路1：双指针</h3><p>使用头尾指针进行匹配，如头尾指针指向的字符不同则判为错,注意边界处理即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean isPalindrome(String s) {        if (s == null || s.length() == 0) {            return true;        }        s = s.toLowerCase();        int low_index = 0;        int high_index= s.length() - 1;        boolean result = true;        while (true) {            while (high_index > low_index  && !isAlpha(s.charAt(low_index))) {                low_index ++;            }            while (high_index > low_index && !isAlpha(s.charAt(high_index))) {                high_index --;            }            if (high_index <= low_index) {                break;            }            else if (high_index > low_index && isAlpha(s.charAt(low_index)) && isAlpha(s.charAt(high_index)) && s.charAt(high_index) != s.charAt(low_index)) {                result = false;                break;            }            else{                high_index --;                low_index++;            }        }        return result;    }    private boolean isAlpha(char ch) {        if ((ch >= '0' && ch <= '9') || (ch  >= 'a' && ch <= 'z')) {            return true;        } else{            return false;        }    }}</code></pre><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><h3 id="思路1-1"><a href="#思路1-1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>n</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>1</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 887:鸡蛋掉落</title>
      <link href="/2020/03/09/leetcode-887-ji-dan-diao-luo/"/>
      <url>/2020/03/09/leetcode-887-ji-dan-diao-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-887-鸡蛋掉落"><a href="#Leetcode-887-鸡蛋掉落" class="headerlink" title="Leetcode 887:鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">Leetcode 887:鸡蛋掉落</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/super-egg-drop" target="_blank" rel="noopener">https://leetcode-cn.com/problems/super-egg-drop</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><pre><code>输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</code></pre><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><pre><code>输入：K = 2, N = 6输出：3示例 3：输入：K = 3, N = 14输出：4</code></pre><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><pre><code>1 &lt;= K &lt;= 1001 &lt;= N &lt;= 10000</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：基本二维DP-二分搜索"><a href="#思路1：基本二维DP-二分搜索" class="headerlink" title="思路1：基本二维DP + 二分搜索"></a>思路1：基本二维DP + 二分搜索</h3><p>直接二维DP计算最少的步骤，根据从x层掉落一个鸡蛋得到，则该情况下的状态转移方程为$DP[K][N] = max(DP[K][N-x], DP[K-1][x-1]) + 1$,从而可得到整体的状态转移方程$DP[K][N] = min(max(DP[K][N-x], DP[K-1][x-1])) + 1 x \isin [1, N]$,同时在dp过程中，前一个函数随x单调递减，后面单调递增，所以可以直接求是两个函数最接近的值作为候选求最小（可用两函数比相交（非整数，或者理解为值域相交，在相同定义域内））。所以该过程可用二分法求解。</p><h3 id="思路2：二维DP-逆向思维（根据步骤数和鸡蛋数求楼数）"><a href="#思路2：二维DP-逆向思维（根据步骤数和鸡蛋数求楼数）" class="headerlink" title="思路2：二维DP + 逆向思维（根据步骤数和鸡蛋数求楼数）"></a>思路2：二维DP + 逆向思维（根据步骤数和鸡蛋数求楼数）</h3><p>可理解为有3元的方程，在一定程度上可根据两元求第3个未知变量，根据题设可以得到一个楼层数与鸡蛋数和步骤的关系，即在特定步骤和鸡蛋数下最多可以测的层数。所以可以得到递推式M为步骤数，K为鸡蛋数，所以状态转移方程为$DP[M][K] = DP[M-1][K-1] + DP[M-1][K] + 1$，该方法考虑的是每增加一步，鸡蛋数增加或减少一个，加1相当于在当前层进行操作。状态初始化是可利用任何一个鸡蛋可探明层数为M层，任何1步K个鸡蛋都只能探明1层，在这个过程中K已知，所以可得到一个可定范围</p><h3 id="思路3：-逆向思维-推导函数-二分搜索"><a href="#思路3：-逆向思维-推导函数-二分搜索" class="headerlink" title="思路3： 逆向思维+推导函数 + 二分搜索"></a>思路3： 逆向思维+推导函数 + 二分搜索</h3><p>使用思路2进而推导出通项公式$f(k,n) = \frac{n(n-1)…(n-k)}{k!} + \frac{n(n-1)(n-2)}{3!} + \frac{n(n-1)}{2!} + n$,<a href="https://leetcode.com/problems/super-egg-drop/discuss/181702/Clear-C%2B%2B-codeRuntime-0-msO(1)-spacewith-explation.No-DPWhat-we-need-is-mathematical-thought!" target="_blank" rel="noopener">推导过程</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public int superEggDrop(int K, int N) {        return eggDropHelper(K, N);    }    private static Map<String, Integer> eggDPs = new HashMap();    private String hasHelper(int K, int N) {        return Integer.toString(K) + "," + Integer.toString(N);    }    private int eggDropHelper(int K, int N) {        if (!eggDPs.containsKey(hasHelper(K, N))) {            int result = 0;            if (K == 1 || N == 0 || N == 1) {                result = N;            } else {                int low = 1;                int high = N;                while (low + 1 < high) {                    int mid = (low + high) / 2;                    int r1 = eggDropHelper(K, N - mid);                    int r2 = eggDropHelper(K - 1, mid - 1);                    if (r1 > r2) {                        low = mid;                    } else if (r1 < r2) {                        high = mid;                    } else {                        low = high = mid;                    }                }                result = 1 + Math.min(Math.max(eggDropHelper(K, N - low), eggDropHelper(K - 1, low - 1)),                        Math.max(eggDropHelper(K, N-high), eggDropHelper(K - 1, high - 1)));            }            eggDPs.put(hasHelper(K, N), result);        }        return eggDPs.get(hasHelper(K, N));    }}</code></pre><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><pre class=" language-Java"><code class="language-Java">public class Solution2 {    public int superEggDrop(int K, int N) {        int ans = 0;        int[] dps = new int[K + 1];        for (int i = 0; i < K + 1; i ++) {            dps[i] = 0;        }        while (dps[K] < N) {            for(int i = K; i > 0; i--) {                dps[i] = 1 + dps[i - 1] + dps[i];            }            ans ++;        }        return ans;    }}</code></pre><h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><pre class=" language-Java"><code class="language-Java">public class Solution3 {    public int superEggDrop(int K, int N) {        int low = 1;        int high = N;        while (low < high) {            int mid = (low + high) / 2;            if (eggHelper(mid, K, N) < N) {                low = mid + 1;            } else {                high = mid;            }        }        return low;    }    private int eggHelper(int mid, int K, int N) {        int result = 0;        int r = 1;        for (int i = 1; i <= K; i++) {            r *= mid - i + 1;            r /= i;            result += r;            if (result > N) break;        }        return result;    }}</code></pre><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>kNlog(N)</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>N * N</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>Klog(N)</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>N</p><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>Klog(N)</p><h4 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>1</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:169. 多数元素</title>
      <link href="/2020/03/05/leetcode-169-duo-shu-yuan-su/"/>
      <url>/2020/03/05/leetcode-169-duo-shu-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>示例1：    输入: [3,2,3]    输出: 3示例2:    输入: [2,2,1,1,1,2,2]    输出: 2</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：hash"><a href="#思路1：hash" class="headerlink" title="思路1：hash"></a>思路1：hash</h3><p>使用hash表存储&lt;num, numCount&gt;数与数出现次数，如果数超过⌊ n/2 ⌋，则该数为众数</p><h3 id="思路2-Boyer-Moore-投票算法"><a href="#思路2-Boyer-Moore-投票算法" class="headerlink" title="思路2: Boyer-Moore 投票算法"></a>思路2: Boyer-Moore 投票算法</h3><p>直接使用计数标记，记录好候选的最多元素，然后因为多数元素超过一半，所以可以不断使用count计数完成候选元素替换、增加、减小。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>                count <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>                count <span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    result <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>思路1和思路2都是n</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>思路1会额外有n的字典，思路2不占用新的空间</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 240:搜索二维矩阵II</title>
      <link href="/2020/03/05/leetcode-240/"/>
      <url>/2020/03/05/leetcode-240/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索二维矩阵II"><a href="#搜索二维矩阵II" class="headerlink" title="搜索二维矩阵II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：每行的元素从左到右升序排列。每列的元素从上到下升序排列。</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>现有矩阵 matrix 如下：    [        [1,   4,  7, 11, 15],        [2,   5,  8, 12, 19],        [3,   6,  9, 16, 22],        [10, 13, 14, 17, 24],        [18, 21, 23, 26, 30]    ]给定 target = 5，返回 true。给定 target = 20，返回 false。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-暴力法"><a href="#思路1-暴力法" class="headerlink" title="思路1 暴力法"></a>思路1 暴力法</h3><p>直接二维数组遍历</p><h3 id="思路2-按照已有顺序遍历"><a href="#思路2-按照已有顺序遍历" class="headerlink" title="思路2: 按照已有顺序遍历"></a>思路2: 按照已有顺序遍历</h3><p>按照题目给的信息，则可根据原数组的排序方式，设置index从数组第一行最后一列元素开始遍历，这样以m+n的算法复杂度得出结果</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路2：代码"><a href="#思路2：代码" class="headerlink" title="思路2：代码"></a>思路2：代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> columns <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> rowIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> colIndex <span class="token operator">=</span> columns <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>rowIndex <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> colIndex <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>rowIndex <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> colIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>rowIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>colIndex<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                colIndex <span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>rowIndex <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> colIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>rowIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>colIndex<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rowIndex <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rowIndex <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> colIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">==</span> matrix<span class="token punctuation">[</span>rowIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>colIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="总结体会"><a href="#总结体会" class="headerlink" title="总结体会"></a>总结体会</h2><p>在实现过程中需要注意下标溢出</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 遍历 </tag>
            
            <tag> 边界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 32:最长有效括号</title>
      <link href="/2020/03/04/leetcode-32/"/>
      <url>/2020/03/04/leetcode-32/</url>
      
        <content type="html"><![CDATA[<h1 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">最长有效括号</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><pre><code>输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h3><pre><code>输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot;</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-DP-Stack"><a href="#思路1-DP-Stack" class="headerlink" title="思路1 DP + Stack"></a>思路1 DP + Stack</h3><p>存在括号匹配可用栈进行存储，寻找满足括号对的存在，但是在本题中光有匹配的数目是不够的，需要从整体上计算匹配上的括号数目，且存在括号包含和括号不包含两种情况，如果非包含关系的话可以使用DP思想将匹配好的为止进行存储</p><h3 id="思路2-Stack"><a href="#思路2-Stack" class="headerlink" title="思路2 Stack"></a>思路2 Stack</h3><p>其实与思路1类似可以直接只是用栈作为容器完成程序，主要在于满足匹配的最长子串的”)”开始索引，然后使用最后匹配的”)”进行位置计算，“(”和中间”)”全部pop,注意的关键点在于初始化栈是将-1引入为第一个元素，充当于”)”</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h4><h4 id="DP-Stack"><a href="#DP-Stack" class="headerlink" title="DP + Stack"></a>DP + Stack</h4><ul><li>Java<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestValidParentheses</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> matchIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> curLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">char</span> newChar <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>newChar <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">else</span><span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  matchIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  curLength <span class="token operator">=</span> i <span class="token operator">-</span> matchIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>matchIndex <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      curLength <span class="token operator">+=</span> dps<span class="token punctuation">[</span>matchIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  dps<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> curLength<span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>curLength <span class="token operator">></span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>                      result <span class="token operator">=</span> curLength<span class="token punctuation">;</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>Python<pre class=" language-Python"><code class="language-Python">class Solution:  def longestValidParentheses(self, s: str) -> int:      dp = [0, ] * len(s)      result = 0      cache = []      for i in range(0, len(s)):          cur_char = s[i]          if cur_char == '(':              cache.append(i)          else:              if len(cache) == 0:                  continue              else:                  match_index = cache.pop()                  cur_len = i - match_index + 1                  if match_index - 1 > 0:                      cur_len += dp[match_index - 1]                  dp[i] = cur_len                  if cur_len > result:                      result = cur_len      return result</code></pre><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4></li><li>Java <pre class=" language-Java"><code class="language-Java">public class Solution2 {  public int longestValidParentheses(String s) {      if (s == null || s.length() < 2) {          return 0;      }      Stack<Integer> stack = new Stack<>();      stack.push(-1);      int result = 0;      int tmp = 0;      for (int i = 0; i < s.length(); i ++) {          if (s.charAt(i) == '(') {              stack.push(i);          } else {              stack.pop();              if (stack.isEmpty()) {                  stack.push(i);              } else {                  tmp = i - stack.peek();                  result = result > tmp ? result : tmp;              }          }      }      return result;  }}</code></pre><h2 id="实验效果分析"><a href="#实验效果分析" class="headerlink" title="实验效果分析"></a>实验效果分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h4 id="Stack-DP"><a href="#Stack-DP" class="headerlink" title="Stack + DP"></a>Stack + DP</h4>$n$<h4 id="Stack-1"><a href="#Stack-1" class="headerlink" title="Stack"></a>Stack</h4>$n$<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h4 id="Stack-DP-1"><a href="#Stack-DP-1" class="headerlink" title="Stack + DP"></a>Stack + DP</h4>$2n$<h4 id="Stack-2"><a href="#Stack-2" class="headerlink" title="Stack"></a>Stack</h4>$n$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> DP </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAE：Rank+(预训练+GNN联合训练)</title>
      <link href="/2020/03/04/sae-yue-du/"/>
      <url>/2020/03/04/sae-yue-du/</url>
      
        <content type="html"><![CDATA[<h1 id="SAE：rank-预训练-GNN联合训练"><a href="#SAE：rank-预训练-GNN联合训练" class="headerlink" title="SAE：rank+(预训练+GNN联合训练)"></a>SAE：rank+(预训练+GNN联合训练)</h1><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="https://arxiv.org/pdf/1911.00484.pdf" target="_blank" rel="noopener">Select, Answer and Explain: Interpretable Multi-hop Reading Comprehension over Multiple Documents</a></p><h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>首先Multi-Head Attention以Rank方式挑选问题相关文章，然后使用预训练模型得到Span信息 + GNN获取支撑句以及回答类型的联合训练的方式得到最终阅读理解的答案以及解释。</p><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>构建目前阅读理解通用流程，并在各个流程中提出自己的优化方法。首先通过对比排序的方式过滤掉答案无关段落，然后通过答案预测任务和支撑句预测任务联合训练得到最终的结果。</p><h3 id="实现亮点"><a href="#实现亮点" class="headerlink" title="实现亮点"></a>实现亮点</h3><ol><li>使用Multi-Head Attention实现对段落的rank<br><img src="https://i.loli.net/2020/03/04/txmFIgXZ8S6quar.png" alt="document_selector.png"><br>rank策略是为段落设定不同的rank值，如果段落为支撑句则rank值为1，若段落包含答案则rank值为2，其余为零。在训练过程中使用句对比较使用Multi-Head Attention进行训练。然后取top k相关段落。</li><li>使用GNN得到支撑句以及答案类型<br><img src="https://i.loli.net/2020/03/04/jFKb8pgYSdMVTCq.png" alt="sup_type_gnn.png"><br>将BERT编码后的Sentence节点输入到GNN中，然后使用GCN的训练策略达到图平衡。然后对平衡后的节点接两层感知机进行支撑句预测，同时使用支撑句label+graph attention+两层感知机的方式获取答案类型</li><li>将span预测、支撑句和答案类型预测联合训练<br><img src="https://i.loli.net/2020/03/04/YDywU7eLtdIcbmp.png" alt="answer_span_sup.png"><br>以上图的方式获得答案span，然后加上上个亮点的支撑段落抽取以及答案类型判断获取联合损失进行训练。<br>$$ L = \gamma L^{span} + BCE(\hat{y}^{sp}, y^{sp}) + CE(\hat{y}^{ans}, y^{ans}) $$<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3>在HotpotQA的非开放域的数据集上实现次SOTA(截止该文章发表)<h4 id="消融实验分析"><a href="#消融实验分析" class="headerlink" title="消融实验分析"></a>消融实验分析</h4></li></ol><ul><li>整体分析<br><img src="https://i.loli.net/2020/03/04/WbyeoSvV7dGU4uP.png" alt="compare.png"><br>整体上比上一轮顶会方法效果提升绝对值较大</li><li>段落挑选分析<br><img src="https://i.loli.net/2020/03/04/LTfGYwjOiI9h75M.png" alt="selector_compare.png"><br>加上支撑段落挑选之后最终效果提升有3%~4%,但是在挑选支撑段落上加上MHSA EM可以提升15%+，该方法提升效果还是很明显的，rank的好处:smile:</li><li>GNN实现效果分析<br><img src="https://i.loli.net/2020/03/04/Jg6PvsA4mZj3YXl.png" alt="gnn_compare.png"><br>从实验来看是否从一个段落中的节点边最有效，有问题实体边以及相同实体效果替身不是很明显 :s。整体来看提升1.4%,提升较小，但是同样重点使用GNN的<a href="https://arxiv.org/pdf/1911.03631.pdf" target="_blank" rel="noopener">HGN</a>提升较大,分层GNN赛高<h3 id="细节发现"><a href="#细节发现" class="headerlink" title="细节发现"></a>细节发现</h3></li><li>在进行段落挑选时选用2效果较好，和齐鹏的<a href="https://arxiv.org/pdf/1910.07000.pdf" target="_blank" rel="noopener">GoldEn Retriever</a>定的参数一样:joy:</li><li>在最后预测时答案和答案类型使用的是两层多层感知机，而是否是支撑段落使用的一层感知机。炼丹++ :s<h2 id="开源可复现"><a href="#开源可复现" class="headerlink" title="开源可复现"></a>开源可复现</h2><h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3>无<h3 id="复现效果"><a href="#复现效果" class="headerlink" title="复现效果"></a>复现效果</h3>无</li></ul>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> 论文阅读 </tag>
            
            <tag> 阅读理解 </tag>
            
            <tag> HotpotQA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotpotQA分析</title>
      <link href="/2019/12/09/hotpotqa-fen-xi/"/>
      <url>/2019/12/09/hotpotqa-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="HotpotQA分析"><a href="#HotpotQA分析" class="headerlink" title="HotpotQA分析"></a>HotpotQA分析</h1><h2 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h2><p><a href="https://arxiv.org/pdf/1809.09600.pdf" target="_blank" rel="noopener">HOTPOTQA: A Dataset for Diverse, Explainable<br>Multi-hop Question Answering</a></p><h2 id="简单数据分析"><a href="#简单数据分析" class="headerlink" title="简单数据分析"></a>简单数据分析</h2><h3 id="数据样例"><a href="#数据样例" class="headerlink" title="数据样例"></a>数据样例</h3><p><img src="https://i.loli.net/2019/12/09/Xru7oOWUNjbLk1M.png" alt="数据样例.png"></p><h3 id="答案长度分布"><a href="#答案长度分布" class="headerlink" title="答案长度分布"></a>答案长度分布</h3><p><img src="https://i.loli.net/2019/12/09/Xru7oOWUNjbLk1M.png" alt="答案长度分布.png"></p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读理解 </tag>
            
            <tag> 数据集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Attention详细解析</title>
      <link href="/2019/12/08/attention-xiang-xi-jie-xi/"/>
      <url>/2019/12/08/attention-xiang-xi-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Attention机制理解"><a href="#Attention机制理解" class="headerlink" title="Attention机制理解"></a>Attention机制理解</h1><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://zhuanlan.zhihu.com/p/47063917" target="_blank" rel="noopener">Attention机制详解（一）——Seq2Seq中的Attention</a></p><h2 id="Attention提出理由"><a href="#Attention提出理由" class="headerlink" title="Attention提出理由"></a>Attention提出理由</h2><h3 id="解决痛点"><a href="#解决痛点" class="headerlink" title="解决痛点"></a>解决痛点</h3><p>在传统的机器翻译中采用encoder-decoder结构，encoder将输入的句子将其转换为定长的向量，然后decoder将向量转化为目标文字。且通常是encoder将最后一层hidden vector作为decoder的起始，然后通过decoder翻译为其他语言。这其中会由于RNN自身特性带来长程梯度消失和并行化差的问题。其中较长的句子也较难在最后的vector中保存需要的有效信息</p><h3 id="提出解决方案"><a href="#提出解决方案" class="headerlink" title="提出解决方案"></a>提出解决方案</h3><p>模拟人翻译的过程，当翻译部分词时将注意力或者更多的注意力放在需要关注的词上，通过类似于赋权的方式计算每个输入位置j与输出位置的关联性。例如可以计算每个输入位置j和当前输出位置的关联性$e_{tj} = a(s_{t-1}, h_j)$,所以写成向量形式就可以得到$\stackrel{-&gt;}{e_t} = (a(s_{t-1}, h_1), …, a(s_{t-1}, h_T))$ $a$是一种相关性的算符，常见的有点乘形式$\stackrel{-&gt;}{e_t}=\stackrel{-&gt;}{s_{t-1}}^T\stackrel{-&gt;}{h}$,加权点乘$\stackrel{-&gt;}{s_{t-1}}^TW\stackrel{-&gt;}{h}$, 加和$\stackrel{-&gt;}{v}^Ttanh(W_1\stackrel{-&gt;}{h} + W_2\stackrel{-&gt;}{s_{t - 1}})$,然后$\stackrel{-&gt;}{s_{t - 1}}$进行softmax操作将normalize得到attention的分布</p><h3 id="self-attention提出原因"><a href="#self-attention提出原因" class="headerlink" title="self-attention提出原因"></a>self-attention提出原因</h3><p>尽可能的去除RNNs网络结构，解决RNN由于其顺序结构进行训练，训练速度会受到约束。在RNN中需要处理对句子中的词一步步地进行顺序处理，并且当它们相距较远时候效果较差。Self-Attention利用了Attention的机制，计算每个单词和其他所有单词之间的关联。可以更好地考虑上下文的信息</p><h3 id="Transformer整体结构解析"><a href="#Transformer整体结构解析" class="headerlink" title="Transformer整体结构解析"></a>Transformer整体结构解析</h3><p>使用Multi-head Attention将多个Self-Attention结构结合，每个head会学习到不同的表征，给模型更大的容量</p><h3 id="Self-Attention详细解析"><a href="#Self-Attention详细解析" class="headerlink" title="Self-Attention详细解析"></a>Self-Attention详细解析</h3><p>Self-Attention基本结构如下<img src="./scaled_dot_product_attention.jpg" alt="avatar"></p><h4 id="对于Self-Attention的利用"><a href="#对于Self-Attention的利用" class="headerlink" title="对于Self-Attention的利用"></a>对于Self-Attention的利用</h4><p>对于Self-Attention来说使用来自一个输入的Q(Query)、K(Key)、V(value)进行计算。首先计算Q与K之间的点乘，然后防止其结果过大，除以一个尺度标度$\sqrt{d_k}$,其中$d_k$为一个query和key向量的维度。再利用Softmax将其结果归一化为概率分布，然后再乘以矩阵V就得到权重求和的表示。该操作表示为$Attention(Q, K, V)=softmax(QK^T\div\sqrt{d_k})V$,其中Q,K,V都是通过输入向量进行矩阵运算得到。有一个可视化较好的<a href="https://zhuanlan.zhihu.com/p/47282410" target="_blank" rel="noopener">解释</a>。需要注意的点是，在类似于encoder和decoder的第一层中q,k,v都是使用来自前一层的decoder的输出，但是在decoder的第二层使用的是来自q是来自encoder的输出，k,v是来自decoder的第一层结果。同时在decoder中使用的不是单纯的Multi-Head Attention而是使用了Masked Multi-Head Attention（因为在翻译过程中不知道后面的输入?)。</p><h4 id="其他结构"><a href="#其他结构" class="headerlink" title="其他结构"></a>其他结构</h4><p>使用了Positional Encoding，该方法主要是将模型没有recurrence和convolution的结构导致没够关于单词在源句子中的位置或绝对的信息，为了让模型更好地学习位置信息的产物，Transformer是使用了三角函数的方式进行encoding。同时在每一步的Multi-Head Attention之后使用了Add和Normanize操作，其中Add表示Residual Connection,该方法是为了解决多层网络训练困难的问题，通过将前一层的信息无差地传递到下一层，可以有效的关注差异部分，这一方法之前在ResNet等图像处理中经常被使用到。而Norm是代表Layer Normalization，该方法通过对层的激活值得归一化，加速模型的训练过程，使得模型可以更快地收敛<a href="https://arxiv.org/pdf/1607.06450.pdf" target="_blank" rel="noopener">Layer Normalization</a></p><h2 id="Attention模型的应用"><a href="#Attention模型的应用" class="headerlink" title="Attention模型的应用"></a>Attention模型的应用</h2><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><h4 id="创造新的结构Universal-Transformers"><a href="#创造新的结构Universal-Transformers" class="headerlink" title="创造新的结构Universal Transformers"></a>创造新的结构Universal Transformers</h4><p><a href="https://arxiv.org/pdf/1807.03819.pdf" target="_blank" rel="noopener">Universal Transformers</a><br><br>该文章结合了Transformer结构和RNN循环归纳的优点，使得Transformer结构能够适用更多自然语言理解的问题。</p><h4 id="创造新的预训练模型Bert等"><a href="#创造新的预训练模型Bert等" class="headerlink" title="创造新的预训练模型Bert等"></a>创造新的预训练模型Bert等</h4><p><a href="https://arxiv.org/pdf/1810.04805.pdf" target="_blank" rel="noopener">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a><br><br>使用双向的Transformer进行预处理，得到包含有上下文信息的表征，根据表征可以fine-tune很多自然语言处理任务，对于GLUE Benchmark(主要包含MNLI,RTE：比较两个句子的语义关系，QQP：判别Quora上两个问题相似度，QNLI：问答，SST-2：情感分析，CoLA:语句合理性判别，STS-B, MRPC：句子相似度判别)，SQuAD(问答)，NER（命名实体识别）等都有极大的提高.</p><h4 id="文本生成"><a href="#文本生成" class="headerlink" title="文本生成"></a>文本生成</h4><p><a href="https://arxiv.org/abs/1801.10198.pdf" target="_blank" rel="noopener">Generating Wikipedia by Summarizing Long Sequences</a></p><h3 id="图像处理及合成"><a href="#图像处理及合成" class="headerlink" title="图像处理及合成"></a>图像处理及合成</h3><h4 id="Attention利用始祖"><a href="#Attention利用始祖" class="headerlink" title="Attention利用始祖"></a>Attention利用始祖</h4><p><a href="https://arxiv.org/abs/1502.03044" target="_blank" rel="noopener">Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</a><br><br>利用Attention机制进行Image Caption(将图像翻译为文字表述)</p><h4 id="文本合成和超分使用"><a href="#文本合成和超分使用" class="headerlink" title="文本合成和超分使用"></a>文本合成和超分使用</h4><p><a href="https://arxiv.org/abs/1802.05751" target="_blank" rel="noopener">Image Transformer</a><br><br>可以使用Attention机制对图像进行合成，例如将局部图像进行补全，也可以将低分辨率的图像还原高分辨率的图像。同时由于Image Transformer模型训练的稳定性，可能和GAN有抗衡之势</p><h3 id="其他领域结合"><a href="#其他领域结合" class="headerlink" title="其他领域结合"></a>其他领域结合</h3><h4 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h4><p><a href="https://arxiv.org/pdf/1711.04725.pdf" target="_blank" rel="noopener">Neural Attentive Session-based Recommendation</a><br><br>利用Attention模型处理用户sesstion中的序列信息进行相关推荐</p><h4 id="音乐生成"><a href="#音乐生成" class="headerlink" title="音乐生成"></a>音乐生成</h4><p><a href="">Generating Long-Term Structure in Songs and Stories</a><br><br>使用Attention RNN创作乐曲</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attention </tag>
            
            <tag> BERT </tag>
            
            <tag> 网络结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNC多粒度支撑段落和支撑句</title>
      <link href="/2019/12/08/unc-duo-li-du-zhi-cheng-duan-luo-he-zhi-cheng-ju/"/>
      <url>/2019/12/08/unc-duo-li-du-zhi-cheng-duan-luo-he-zhi-cheng-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="UNC多粒度支撑段落和支撑句"><a href="#UNC多粒度支撑段落和支撑句" class="headerlink" title="UNC多粒度支撑段落和支撑句"></a>UNC多粒度支撑段落和支撑句</h1><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="https://arxiv.org/pdf/1909.08041.pdf" target="_blank" rel="noopener">Revealing the Importance of Semantic Retrieval<br>for Machine Reading at Scale</a></p><h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>通过term按照文本相关性搜索到可靠数量的段落，然后通过神经网络模型召回支撑段落，然后再在支撑段落里召回支撑句，并且文章做了大量的消融实验证明了支撑段落具有重大意义，支撑句需要有一些噪音效果才比较好。</p><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h2 id="开源可复现"><a href="#开源可复现" class="headerlink" title="开源可复现"></a>开源可复现</h2><p>开源</p><h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3><p><a href="easonnie/semanticRetrievalMRS">easonnie/semanticRetrievalMRS</a></p><h3 id="复现效果"><a href="#复现效果" class="headerlink" title="复现效果"></a>复现效果</h3><p>无</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文阅读 </tag>
            
            <tag> IR </tag>
            
            <tag> 信息检索 </tag>
            
            <tag> hotpotqa </tag>
            
            <tag> emnlp </tag>
            
            <tag> 2019 </tag>
            
            <tag> multi-hot </tag>
            
            <tag> 消融实验 </tag>
            
            <tag> 需要精读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微软实验室HGN分层图网络</title>
      <link href="/2019/12/08/wei-ruan-shi-yan-shi-hgn-fen-ceng-tu-wang-luo/"/>
      <url>/2019/12/08/wei-ruan-shi-yan-shi-hgn-fen-ceng-tu-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="微软实验室HGN分层图网络"><a href="#微软实验室HGN分层图网络" class="headerlink" title="微软实验室HGN分层图网络"></a>微软实验室HGN分层图网络</h1><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="https://arxiv.org/pdf/1911.03631.pdf" target="_blank" rel="noopener">Hierarchical Graph Network for Multi-hop Question Answering</a></p><h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>使用图神经网络实现段落、句子、实体关联加入到多步问答中，做了大量消融实验，包含各个层之间的消融以及不同预训练模型的消融</p><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h2 id="开源可复现"><a href="#开源可复现" class="headerlink" title="开源可复现"></a>开源可复现</h2><p>非开源</p><h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3><p>无</p><h3 id="复现效果"><a href="#复现效果" class="headerlink" title="复现效果"></a>复现效果</h3><p>无</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文阅读 </tag>
            
            <tag> 阅读理解 </tag>
            
            <tag> 图神经网络 </tag>
            
            <tag> 多层图神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2019/12/08/blog-builder/"/>
      <url>/2019/12/08/blog-builder/</url>
      
        <content type="html"><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://godweiyang.com/about/" target="_blank" rel="noopener">韦阳的博客</a></p><h2 id="实际使用主题"><a href="#实际使用主题" class="headerlink" title="实际使用主题"></a>实际使用主题</h2><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a></p><h2 id="主题目前特色实现功能"><a href="#主题目前特色实现功能" class="headerlink" title="主题目前特色实现功能"></a>主题目前特色实现功能</h2><ul><li>标签和分类</li><li>文档搜索</li><li>gittalk集成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答</title>
      <link href="/2019/12/08/si-tan-fu-nlp-qi-peng-duo-bu-wen-ti-sheng-cheng-shi-xian-hotpotqa-kai-fang-yu-wen-da/"/>
      <url>/2019/12/08/si-tan-fu-nlp-qi-peng-duo-bu-wen-ti-sheng-cheng-shi-xian-hotpotqa-kai-fang-yu-wen-da/</url>
      
        <content type="html"><![CDATA[<h1 id="斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答"><a href="#斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答" class="headerlink" title="斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答"></a>斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答</h1><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="https://arxiv.org/pdf/1910.07000.pdf" target="_blank" rel="noopener">Answering Complex Open-domain Questions Through Iterative Query Generation</a></p><h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>使用启发式的方法进行多步问题的细粒度化，在召回量较少的情况下得到高准确率的支撑文档，进而提高开放域问答的效果，并完成一个完整的Pipeline的工作,其中包含很多小技巧，包含在Content和question编码的时候使用0、1而不是cls/sep，提高实验基线。</p><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h2 id="开源可复现"><a href="#开源可复现" class="headerlink" title="开源可复现"></a>开源可复现</h2><h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3><p><a href="https://github.com/qipeng/golden-retriever" target="_blank" rel="noopener">golden-retriever</a></p><h3 id="复现效果"><a href="#复现效果" class="headerlink" title="复现效果"></a>复现效果</h3><p>暂无</p><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p>hotpotqa 开放域 问答 问题生成 多步 EMNLP2019</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读理解 </tag>
            
            <tag> 个人论文理解 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
