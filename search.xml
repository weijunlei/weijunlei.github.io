<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Leetcode:160. 相交链表</title>
      <link href="/2020/04/06/leetcode-160-xiang-jiao-lian-biao/"/>
      <url>/2020/04/06/leetcode-160-xiang-jiao-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-160-相交链表"><a href="#Leetcode-160-相交链表" class="headerlink" title="[Leetcode:160.相交链表]"></a>[Leetcode:160.相交链表]</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>编写一个程序，找到两个单链表相交的起始节点。如下面的两个链表：在节点 c1 开始相交。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><pre><code>如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>对链表的节点数量计数后分别遍历，然后长的链表先遍历完注定不相交的前段，然后开始同时遍历知道相同</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {       if ((headA == null && headB != null) || (headA != null && headB == null)){          return null;       }        int countA = 0, countB = 0;        ListNode preA = headA, preB = headB;        while (preA != null){            preA = preA.next;            countA += 1;        }        while (preB != null){            preB = preB.next;            countB += 1;        }        preA = headA;        preB = headB;        while(countA > countB){            preA = preA.next;            countA--;        }        while(countA < countB){            preB = preB.next;            countB--;        }        while(preA != null){            if (preA == preB){                return preA;            }            preA = preA.next;            preB = preB.next;        }        return null;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="代码1时间复杂度"><a href="#代码1时间复杂度" class="headerlink" title="代码1时间复杂度"></a>代码1时间复杂度</h3><p>$O(n)$</p><h3 id="代码1空间复杂度"><a href="#代码1空间复杂度" class="headerlink" title="代码1空间复杂度"></a>代码1空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:148. 排序链表</title>
      <link href="/2020/04/06/leetcode-148-pai-xu-lian-biao/"/>
      <url>/2020/04/06/leetcode-148-pai-xu-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>#<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="noopener">Leetcode: 141.排序链表</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: 4-&gt;2-&gt;1-&gt;3输出: 1-&gt;2-&gt;3-&gt;4</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>使用快排实现，值修改</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用归并排序，实现平均复杂度$O(n)$,因为链表可以直接引用空间，所以可以不用额外的$O(nlogn)$空间，需要注意获取中间节点的快指针位置初始设置</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><pre class=" language-Java"><code class="language-Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode sortList(ListNode head) {        if (head == null || head.next == null){            return head;        }        quickSort(head, null);        return head;    }    private void quickSort(ListNode head, ListNode end){        if (head != end){            ListNode midNode = getPartition(head, end);            quickSort(head, midNode);            quickSort(midNode.next, end);        }    }    private ListNode getPartition(ListNode head, ListNode end){        ListNode getNode = head;        int getNum = head.val;        ListNode pre = head.next;        while(pre != null){            if (pre == end){                break;            }            if (pre.val < getNum){                getNode = getNode.next;                int tempNum = pre.val;                pre.val = getNode.val;                getNode.val = tempNum;            }            pre = pre.next;        }        int tempNum = getNode.val;        getNode.val = head.val;        head.val = tempNum;        return getNode;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */class Solution {    public ListNode sortList(ListNode head) {        if (head == null || head.next == null){            return head;        }        ListNode pre = head.next;        ListNode middle = head;        while (pre != null && pre.next != null){            pre = pre.next.next;            middle = middle.next;        }        pre = middle.next;        middle.next = null;        ListNode left = sortList(head);        ListNode right = sortList(pre);        ListNode result = new ListNode(0);        ListNode temp = result;        while (left != null && right != null){            if (left.val < right.val){                temp.next = left;                left = left.next;            }else{                temp.next = right;                right = right.next;            }            temp = temp.next;        }        temp.next = right;        if (left != null){            temp.next = left;        }        return result.next;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>最坏$O(n^2)$，平均$O(nlogn)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(1)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(nlogn)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 快排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:141. 环形链表</title>
      <link href="/2020/04/06/leetcode-141-huan-xing-lian-biao/"/>
      <url>/2020/04/06/leetcode-141-huan-xing-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-141-环形链表"><a href="#Leetcode-141-环形链表" class="headerlink" title="Leetcode:141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Leetcode:141. 环形链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h3><pre><code>你能用 O(1)（即，常量）内存解决此问题吗？</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>快慢指针，使用快慢指针遍历链表看是否会有相交</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public boolean hasCycle(ListNode head) {        if (head == null || head.next == null){            return false;        }        ListNode fast = head;        ListNode slow = head;        do{            slow = slow.next;            fast = fast.next != null ? fast.next.next : null;        }        while (fast != null && slow != null && (fast != slow));        if (fast == slow && fast != null){            return true;        }else{            return false;        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:138. 复制带随机指针的链表</title>
      <link href="/2020/04/06/leetcode-138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/"/>
      <url>/2020/04/06/leetcode-138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-138-复制带随机指针的链表"><a href="#Leetcode-138-复制带随机指针的链表" class="headerlink" title="Leetcode:138. 复制带随机指针的链表"></a><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer" target="_blank" rel="noopener">Leetcode:138. 复制带随机指针的链表</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的 深拷贝。 我们用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：val：一个表示 Node.val 的整数。random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入：head = [[1,1],[2,1]]输出：[[1,1],[2,1]]</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入：head = [[3,null],[3,0],[3,null]]输出：[[3,null],[3,0],[3,null]]</code></pre><h3 id="示例-4："><a href="#示例-4：" class="headerlink" title="示例 4："></a>示例 4：</h3><pre><code>输入：head = []输出：[]解释：给定的链表为空（空指针），因此返回 null。</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><pre><code>-10000 &lt;= Node.val &lt;= 10000Node.random 为空（null）或指向链表中的节点。节点数目不超过 1000 。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>//TODO：其他思路</p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接在原来的链表位置旁复制，然后遍历分离</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">/*// Definition for a Node.class Node {    int val;    Node next;    Node random;    public Node(int val) {        this.val = val;        this.next = null;        this.random = null;    }}*/class Solution {    public Node copyRandomList(Node head) {        if (head == null){            return null;        }        Node pre = head;        while(pre != null){            Node newNode = new Node(pre.val);            newNode.next = pre.next;            pre.next = newNode;            pre = pre.next.next;        }        pre = head;        while(pre != null){            if (pre.next != null && pre.random != null){                pre.next.random = pre.random.next;            } else {                pre.next.random = null;            }            pre = pre.next.next;        }        Node origin = head;        pre = head.next;        Node result = head.next;        while(pre != null){            origin.next = origin.next.next;            if (pre.next == null){                pre.next = null;            }else{                pre.next = pre.next.next;            }            origin = origin.next;            pre = pre.next;        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度分析"><a href="#思路1空间复杂度分析" class="headerlink" title="思路1空间复杂度分析"></a>思路1空间复杂度分析</h3><p>$O(1)$如果不算结果空间</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:150. 逆波兰表达式求值</title>
      <link href="/2020/04/05/leetcode-150-ni-bo-lan-biao-da-shi-qiu-zhi/"/>
      <url>/2020/04/05/leetcode-150-ni-bo-lan-biao-da-shi-qiu-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-150-逆波兰表达式求值"><a href="#Leetcode-150-逆波兰表达式求值" class="headerlink" title="Leetcode:150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">Leetcode:150. 逆波兰表达式求值</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>整数除法只保留整数部分。给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]输出: 9解释: ((2 + 1) * 3) = 9</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]输出: 6解释: (4 + (13 / 5)) = 6</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]输出: 22解释: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用栈解决，需要注意数字先进后出问题</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">class Solution {    public int evalRPN(String[] tokens) {        if (tokens == null || tokens.length == 0){            return 0;        }        Stack<Integer> stack = new Stack<>();        int num1 = 0;        int num2 = 0;        for(String token: tokens){            if (token.equals("+") || token.equals("-") || token.equals("*") || token.equals("/")){                num1 = stack.pop();                num2 = stack.pop();                switch(token){                    case "+":                        stack.push(num1 + num2);                        break;                    case "-":                        stack.push(num2 - num1);                        break;                    case "*":                        stack.push(num2 * num1);                        break;                    case "/":                        stack.push(num2 / num1);                }            } else {                stack.push(Integer.valueOf(token));            }        }        return stack.pop();    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:341. 扁平化嵌套列表迭代器</title>
      <link href="/2020/04/05/leetcode-341-bian-ping-hua-qian-tao-lie-biao-die-dai-qi/"/>
      <url>/2020/04/05/leetcode-341-bian-ping-hua-qian-tao-lie-biao-die-dai-qi/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-341-扁平化嵌套列表迭代器"><a href="#Leetcode-341-扁平化嵌套列表迭代器" class="headerlink" title="Leetcode:341. 扁平化嵌套列表迭代器"></a><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/" target="_blank" rel="noopener">Leetcode:341. 扁平化嵌套列表迭代器</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [[1,1],2,[1,1]]输出: [1,1,2,1,1]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [1,[4,[6]]]输出: [1,4,6]解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用深度优先遍历获取递归的数字</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger { * *     // @return true if this NestedInteger holds a single integer, rather than a nested list. *     public boolean isInteger(); * *     // @return the single integer that this NestedInteger holds, if it holds a single integer *     // Return null if this NestedInteger holds a nested list *     public Integer getInteger(); * *     // @return the nested list that this NestedInteger holds, if it holds a nested list *     // Return null if this NestedInteger holds a single integer *     public List<NestedInteger> getList(); * } */public class NestedIterator implements Iterator<Integer> {    Queue<Integer> queue;    public NestedIterator(List<NestedInteger> nestedList) {        queue = new LinkedList<Integer>();        for(NestedInteger node: nestedList){            DFS(node);        }    }    @Override    public Integer next() {        return queue.poll();    }    @Override    public boolean hasNext() {        return !queue.isEmpty();    }    private void DFS(NestedInteger node){        if (node.isInteger()){            queue.offer(node.getInteger());        } else {            for(NestedInteger sonNode: node.getList()){                DFS(sonNode);            }        }    }}/** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i = new NestedIterator(nestedList); * while (i.hasNext()) v[f()] = i.next(); */</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$,n为元素个数</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DFS </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:227. 基本计算器 II</title>
      <link href="/2020/04/04/leetcode-227-ji-ben-ji-suan-qi-ii/"/>
      <url>/2020/04/04/leetcode-227-ji-ben-ji-suan-qi-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-227-基本计算器-II"><a href="#Leetcode-227-基本计算器-II" class="headerlink" title="Leetcode 227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">Leetcode 227. 基本计算器 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>实现一个基本的计算器来计算一个简单的字符串表达式的值。字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: &quot;3+2*2&quot;输出: 7</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: &quot; 3/2 &quot;输出: 1</code></pre><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><pre><code>输入: &quot; 3+5 / 2 &quot;输出: 5</code></pre><p>说明：<br>    你可以假设所给定的表达式都是有效的。<br>    请不要使用内置的库函数 eval。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：栈"><a href="#思路1：栈" class="headerlink" title="思路1：栈"></a>思路1：栈</h3><p>使用一个栈存储数字，然后使用一个符号记录延后记录运算符，初始为+，最后出栈相加即可得到最后的结果</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int calculate(String s) {        if (s == null || s.length() == 0){            return 0;        }        int result = 0;        int tempNum = 0;        char tempOp = '+';        int getNum = 0;        Stack<Integer> stack = new Stack<>();        for(int i = 0; i < s.length(); i++){            char ch = s.charAt(i);            if (ch >= '0' && ch <= '9'){                tempNum = tempNum * 10 + ch - '0';            }             if ((ch != ' ' && (ch < '0' || ch  > '9')) || i == s.length() - 1){                switch(tempOp){                    case '+':                        stack.push(tempNum);                        break;                    case '-':                        stack.push(-tempNum);                        break;                    case '*':                        getNum = stack.peek() * tempNum;                        stack.pop();                        stack.push(getNum);                        break;                    case '/':                        getNum = stack.peek() / tempNum;                        stack.pop();                        stack.push(getNum);                        break;                }                tempNum = 0;                tempOp = ch;            }        }        while(!stack.isEmpty()){            result += stack.pop();        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:239. 滑动窗口最大值</title>
      <link href="/2020/04/03/leetcode-239-hua-dong-chuang-kou-zui-da-zhi/"/>
      <url>/2020/04/03/leetcode-239-hua-dong-chuang-kou-zui-da-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-239-滑动窗口最大值"><a href="#Leetcode-239-滑动窗口最大值" class="headerlink" title="Leetcode: 239. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Leetcode: 239. 滑动窗口最大值</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。进阶：你能在线性时间复杂度内解决此题吗？</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7] 解释: 滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       31 [3  -1  -3] 5  3  6  7       31  3 [-1  -3  5] 3  6  7       51  3  -1 [-3  5  3] 6  7       51  3  -1  -3 [5  3  6] 7       61  3  -1  -3  5 [3  6  7]      7</code></pre><h3 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h3><pre><code>1 &lt;= nums.length &lt;= 10^5-10^4 &lt;= nums[i] &lt;= 10^41 &lt;= k &lt;= nums.length</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：优先级队列"><a href="#思路1：优先级队列" class="headerlink" title="思路1：优先级队列"></a>思路1：优先级队列</h3><p>使用优先级队列存储一个k的最大堆，大于k时每次去除前面的第k个元素</p><h3 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h3><p>将原数组设置为k个一个单元，然后分别求从左至当前位置的最大值（不超过k单元内）和从右至左，这样可以直接求两个边界最大值即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums == null || nums.length == 0){            return nums;        }        PriorityQueue<Integer> pq = new  PriorityQueue<Integer>(Collections.reverseOrder());        int[] result = new int[nums.length - k + 1];        for(int i = 0; i < nums.length; i++){            if (i >= k) pq.remove(nums[i - k]);            pq.offer(nums[i]);            if (i + 1 >= k) result[i + 1 - k] = pq.peek();        }        return result;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums == null || nums.length == 0){            return nums;        }        int n = nums.length;        int[] leftDPs = new int[n];        int[] rightDPs = new int[n];        leftDPs[0] = nums[0];        rightDPs[n - 1] = nums[n - 1];        int[] result = new int[n - k + 1];        for(int i = 1; i < n; i++){            if (i % k != 0){                leftDPs[i] = Math.max(nums[i], leftDPs[i - 1]);            } else {                leftDPs[i] = nums[i];            }            int rightIndex = n - i - 1;            if (rightIndex % k != 0){                rightDPs[rightIndex] = Math.max(nums[rightIndex], rightDPs[rightIndex + 1]);            }else {                rightDPs[rightIndex] = nums[rightIndex];            }        }        for(int i = 0; i < n - k + 1; i++){            result[i] = Math.max(rightDPs[i], leftDPs[i + k - 1]);        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(nlogk)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> 优先级队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:347. 前 K 个高频元素</title>
      <link href="/2020/04/01/leetcode-347-qian-k-ge-gao-pin-yuan-su/"/>
      <url>/2020/04/01/leetcode-347-qian-k-ge-gao-pin-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-347-前-K-个高频元素"><a href="#Leetcode-347-前-K-个高频元素" class="headerlink" title="Leetcode:347. 前 K 个高频元素"></a><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Leetcode:347. 前 K 个高频元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: nums = [1], k = 1输出: [1]</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>维护一个大小为K的最小堆，根据数字出现次数排序</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>使用桶排序，维护一个出现次数的二维数组</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<Integer> topKFrequent(int[] nums, int k) {        Map<Integer, Integer> map = new HashMap<Integer, Integer>();        for(int num: nums){            if (!map.containsKey(num)){                map.put(num, 1);            } else{                map.put(num, map.get(num) + 1);            }        }        PriorityQueue<Integer> pq =                new PriorityQueue<Integer>((n1, n2) -> map.get(n1) - map.get(n2));        for(int num: map.keySet()){            pq.add(num);            if (pq.size() > k){                pq.poll();            }        }        List<Integer> maxQueue = new ArrayList<>();        while (pq.size() != 0){            maxQueue.add(pq.poll());        }        Collections.reverse(maxQueue);        return maxQueue;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<Integer> topKFrequent(int[] nums, int k) {        Map<Integer, Integer> map = new HashMap<Integer, Integer>();        for(int num: nums){            if (!map.containsKey(num)){                map.put(num, 1);            } else{                map.put(num, map.get(num) + 1);            }        }        List<Integer>[] sizeCount = new List[nums.length];        for(int num: map.keySet()){            int getCount = map.get(num) - 1;            if (sizeCount[getCount] == null){                sizeCount[getCount] = new ArrayList<Integer>();            }            sizeCount[getCount].add(num);        }        List<Integer> maxQueue = new ArrayList<>();        for(int i = nums.length - 1; i >= 0 && maxQueue.size() < k; i--){            if (sizeCount[i] == null){                continue;            }else {                maxQueue.addAll(sizeCount[i]);            }        }        return maxQueue;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(nlogk)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路1时间复杂度-1"><a href="#思路1时间复杂度-1" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 桶排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:378. 有序矩阵中第K小的元素</title>
      <link href="/2020/03/31/leetcode-378-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/"/>
      <url>/2020/03/31/leetcode-378-you-xu-ju-zhen-zhong-di-k-xiao-de-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-378-有序矩阵中第K小的元素"><a href="#Leetcode-378-有序矩阵中第K小的元素" class="headerlink" title="Leetcode:378. 有序矩阵中第K小的元素"></a><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">Leetcode:378. 有序矩阵中第K小的元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。请注意，它是排序后的第k小元素，而不是第k个元素。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>matrix = [[ 1,  5,  9],[10, 11, 13],[12, 13, 15]],k = 8,</code></pre><p>返回 13。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>你可以假设 k 的值永远是有效的, 1 ≤ k ≤ n2 。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：二分法"><a href="#思路1：二分法" class="headerlink" title="思路1：二分法"></a>思路1：二分法</h3><p>使用两个哨兵分别记录最大值和最小值（可以取到第k个值的区间），然后计算中间值的大小，根据这个中间值计算第k个值在二分区间中的位置，或者是大于多少个矩阵中的值，若比k大则属于前半区间，若小于等于k则处于后半区间，等于由于可能中间值不是矩阵中的值所以不能直接返回</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int kthSmallest(int[][] matrix, int k) {        if (matrix == null || matrix.length == 0 || matrix[0].length == 0){            throw new RuntimeException("matrix is empty!");        }        int rowSize = matrix.length;        int colSize = matrix[0].length;        if (k > colSize * rowSize){            throw new RuntimeException("matrix is less than k!");        }        int left = matrix[0][0];        int right = matrix[matrix.length - 1][matrix[0].length - 1];        int count = -1;        while (left < right){            int mid = (left + right) / 2;            count = getCount(matrix, mid, rowSize, colSize);            if (count < k){                left = mid + 1;            }else{                right = mid;            }        }        return right;    }    private int getCount(int[][] matrix,int mid,int rowSize,int colSize){        int rowIndex = rowSize - 1;        int colIndex = 0;        int count = 0;        while (rowIndex >= 0 && colIndex < colSize){            if (matrix[rowIndex][colIndex] <= mid){                count += rowIndex + 1;                colIndex ++;            }else{                rowIndex --;            }        }        return count;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(nlogn * log (max -min))$log(max - min)是因为有中间值逼近的过程</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:295. 数据流的中位数</title>
      <link href="/2020/03/30/leetcode-295-shu-ju-liu-de-zhong-wei-shu/"/>
      <url>/2020/03/30/leetcode-295-shu-ju-liu-de-zhong-wei-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-295-数据流的中位数"><a href="#Leetcode-295-数据流的中位数" class="headerlink" title="Leetcode:295. 数据流的中位数"></a><a href="https://leetcode-cn.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">Leetcode:295. 数据流的中位数</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。例如，[2,3,4] 的中位数是 3[2,3] 的中位数是 (2 + 3) / 2 = 2.5设计一个支持以下两种操作的数据结构：void addNum(int num) - 从数据流中添加一个整数到数据结构中。double findMedian() - 返回目前所有元素的中位数。</code></pre><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code>addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2</code></pre><p>进阶:<br>    如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？<br>    如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：借用插入排序方法，每次插入后保持有序"><a href="#思路1：借用插入排序方法，每次插入后保持有序" class="headerlink" title="思路1：借用插入排序方法，每次插入后保持有序"></a>思路1：借用插入排序方法，每次插入后保持有序</h3><p>使用插入排序思路，每次插入新的数据后数据保持有序，这样时间复杂度主要来自于插入的O(n)<br>// TODO:其他思路</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1：插入排序思路"><a href="#代码1：插入排序思路" class="headerlink" title="代码1：插入排序思路"></a>代码1：插入排序思路</h3><pre class=" language-Java"><code class="language-Java">class MedianFinder {    private List<Integer> list;    /** initialize your data structure here. */    public MedianFinder() {        list = new ArrayList<>();    }    public void addNum(int num) {        if (list.isEmpty()){            list.add(num);            return;        }        int insertIndex = 0;        for(; insertIndex < list.size(); insertIndex++){            if(list.get(insertIndex) > num){                break;            }        }        list.add(insertIndex, num);    }    public double findMedian() {        if (list.size() % 2 != 0){            return list.get(list.size() / 2);        } else {            return 1.0 * (list.get(list.size() / 2 - 1) + list.get(list.size() / 2)) / 2;        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="代码1时间复杂度"><a href="#代码1时间复杂度" class="headerlink" title="代码1时间复杂度"></a>代码1时间复杂度</h3><p>主要是插入排序的时间每次为O(n)</p><h3 id="代码1空间复杂度"><a href="#代码1空间复杂度" class="headerlink" title="代码1空间复杂度"></a>代码1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:215. 数组中的第K个最大元素</title>
      <link href="/2020/03/29/leetcode-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su/"/>
      <url>/2020/03/29/leetcode-215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">215. 数组中的第K个最大元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [3,2,1,5,6,4] 和 k = 2输出: 5</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>采用快排的获取主元排序索引，更新到符合K大的位置</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int findKthLargest(int[] nums, int k) {        if (nums == null || nums.length < k){            return -1;        }        int result = -1;        int start = 0;        int end = nums.length - 1;        result = getIndex(nums, start, end);        while (result != k - 1){            if (result > k - 1){                end = result;                result = getIndex(nums, start, end - 1);            } else if(result < k - 1){                start = result;                result = getIndex(nums, start + 1, end);            }        }        if (result == k - 1){            return nums[k - 1];        }else {            return -1;        }    }    private int getIndex(int[] nums, int s, int e){        int getNum = nums[s];        int getIndex = s;        swap(nums, s, e);        for(int i = s; i < e; i++){            if (nums[i] > getNum){                swap(nums, getIndex, i);                getIndex ++;            }        }        swap(nums, getIndex, e);        return getIndex;    }    private void swap(int[] nums, int i, int j){        int temp = nums[i];        nums[i] = nums[j];        nums[j] = temp;    }}</code></pre><p>// TODO:其他思路</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>平均$O(n)$,最坏$(n^2)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 快排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:155. 最小栈</title>
      <link href="/2020/03/28/leetcode-155-zui-xiao-zhan/"/>
      <url>/2020/03/28/leetcode-155-zui-xiao-zhan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-155-最小栈"><a href="#Leetcode-155-最小栈" class="headerlink" title="Leetcode:155. 最小栈"></a><a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">Leetcode:155. 最小栈</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) -- 将元素 x 推入栈中。pop() -- 删除栈顶的元素。top() -- 获取栈顶元素。getMin() -- 检索栈中的最小元素。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>主要还是栈，只是在栈的基础上获取栈中最小值，所以可以直接构建一个辅助栈，每次入栈时都记录当前位置下栈的最小数，出栈时只需要一起出即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class MinStack {    /** initialize your data structure here. */    private Stack<Integer> stack;    private Stack<Integer> stackHelper;    public MinStack() {        stack = new Stack<>();        stackHelper = new Stack<>();    }    public void push(int x) {        stack.add(x);        if (stackHelper.isEmpty() || x < stackHelper.peek()){            stackHelper.add(x);        }else {            stackHelper.add(stackHelper.peek());        }    }    public void pop() {        if (!stack.isEmpty()){            stack.pop();            stackHelper.pop();        } else {            throw new RuntimeException("Stack is empty!");        }    }    public int top() {        if (!stack.isEmpty()){            return stack.peek();        } else {            throw new RuntimeException("Stack is empty!");        }    }    public int getMin() {        if (!stackHelper.isEmpty()){            return stackHelper.peek();        } else {            throw new RuntimeException("Stack is empty!");        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(1)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:238. 除自身以外数组的乘积</title>
      <link href="/2020/03/28/leetcode-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/"/>
      <url>/2020/03/28/leetcode-238-chu-zi-shen-yi-wai-shu-zu-de-cheng-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-238-除自身以外数组的乘积"><a href="#Leetcode-238-除自身以外数组的乘积" class="headerlink" title="Leetcode: 238. 除自身以外数组的乘积"></a><a href="https://leetcode-cn.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">Leetcode: 238. 除自身以外数组的乘积</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: [1,2,3,4]输出: [24,12,8,6]提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</code></pre><h3 id="进阶："><a href="#进阶：" class="headerlink" title="进阶："></a>进阶：</h3><p>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：分别进行左右乘法"><a href="#思路1：分别进行左右乘法" class="headerlink" title="思路1：分别进行左右乘法"></a>思路1：分别进行左右乘法</h3><p>对所有位置的结果分为左边乘和右边乘，使用一个临时变量记录左乘(右乘)积，带入到相应位置，详情见代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] productExceptSelf(int[] nums) {        int[] result = new int[nums.length];        for(int i = 0; i < result.length; i++){            result[i] = 1;        }        int tempResult = 1;        for(int i = 0; i < result.length - 1; i++){            tempResult *= nums[i];            result[i+1] *= tempResult;        }        tempResult = 1;        for(int i = result.length - 1; i > 0; i--){            tempResult *= nums[i];            result[i - 1] *= tempResult;        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(N)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$除去结果空间以外</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:334. 递增的三元子序列</title>
      <link href="/2020/03/27/leetcode-334-di-zeng-de-san-yuan-zi-xu-lie/"/>
      <url>/2020/03/27/leetcode-334-di-zeng-de-san-yuan-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h1 id="334-递增的三元子序列"><a href="#334-递增的三元子序列" class="headerlink" title="334. 递增的三元子序列"></a><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/" target="_blank" rel="noopener">334. 递增的三元子序列</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个未排序的数组，判断这个数组中是否存在长度为 3 的递增子序列。数学表达式如下:如果存在这样的 i, j, k,  且满足 0 ≤ i &lt; j &lt; k ≤ n-1，使得 arr[i] &lt; arr[j] &lt; arr[k] ，返回 true ; 否则返回 false 。说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1) 。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [1,2,3,4,5]输出: true</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [5,4,3,2,1]输出: false</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：DP"><a href="#思路1：DP" class="headerlink" title="思路1：DP"></a>思路1：DP</h3><p>使用状态方程记录数组每个位置的最大递增序列大小，状态转移方程为$dps[i] = max(dps[i], dps[j] + 1 if nums[j] &lt; nums[i]) j \isin [0, i)</p><h3 id="思路2：加入两个哨兵元素"><a href="#思路2：加入两个哨兵元素" class="headerlink" title="思路2：加入两个哨兵元素"></a>思路2：加入两个哨兵元素</h3><p>使用两个哨兵元素记录值，即记录两个最小的数</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean increasingTriplet(int[] nums) {        if (nums == null || nums.length < 3){            return false;        }        int[] dps = new int[nums.length];        for(int i = 1; i < nums.length; i++){            for(int j = 0; j < i; j++){                if (nums[i] > nums[j]){                    dps[i] = Math.max(dps[i], dps[j] + 1);                    if (dps[i] == 2){                        return true;                    }                }            }        }        return false;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean increasingTriplet(int[] nums) {        if (nums == null || nums.length < 3){            return false;        }        int max1 = Integer.MAX_VALUE;        int max2 = Integer.MAX_VALUE;        for(int num: nums){            if (num <= max1){                max1 = num;            } else if (num <= max2){                max2 = num;            } else {                return true;            }        }        return false;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n^2)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DP </tag>
            
            <tag> Medium </tag>
            
            <tag> 数组 </tag>
            
            <tag> 哨兵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:350. 两个数组的交集 II</title>
      <link href="/2020/03/27/leetcode-350-liang-ge-shu-zu-de-jiao-ji-ii/"/>
      <url>/2020/03/27/leetcode-350-liang-ge-shu-zu-de-jiao-ji-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定两个数组，编写一个函数来计算它们的交集。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: nums1 = [1,2,2,1], nums2 = [2,2]输出: [2,2]</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出: [4,9]</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h3><pre><code>如果给定的数组已经排好序呢？你将如何优化你的算法？如果 nums1 的大小比 nums2 小很多，哪种方法更优？如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-两个数组排序后使用两个指针遍历比较"><a href="#思路1-两个数组排序后使用两个指针遍历比较" class="headerlink" title="思路1: 两个数组排序后使用两个指针遍历比较"></a>思路1: 两个数组排序后使用两个指针遍历比较</h3><p>对两个数组分别排序，然后使用一个哨兵分别计数，若两位置相等则加入，否则按照排序递增</p><h3 id="思路2-使用Hash计数"><a href="#思路2-使用Hash计数" class="headerlink" title="思路2: 使用Hash计数"></a>思路2: 使用Hash计数</h3><p>对一个数组hash计数，然后使用另外一个等相等加入</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] intersect(int[] nums1, int[] nums2) {        List<Integer> result = new ArrayList<>();        Arrays.sort(nums1);        Arrays.sort(nums2);        int aIndex = 0;        int bIndex = 0;        while(aIndex < nums1.length && bIndex < nums2.length){            if (nums1[aIndex] == nums2[bIndex]){                result.add(nums1[aIndex]);                aIndex ++;                bIndex ++;            } else if(nums1[aIndex] < nums2[bIndex]){                aIndex ++;            } else {                bIndex ++;            }        }        int[] intResult = new int[result.size()];        for(int i = 0; i < result.size(); i++){            intResult[i] = result.get(i);        }        return intResult;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int[] intersect(int[] nums1, int[] nums2) {        List<Integer> result = new ArrayList<>();        Map<Integer, Integer> hashMap = new HashMap<>();        for(int num: nums1){            if (!hashMap.containsKey(num)){                hashMap.put(num, 0);            }            hashMap.put(num, hashMap.get(num) + 1);        }        for(int num: nums2){            if (hashMap.containsKey(num) && hashMap.get(num) > 0){                result.add(num);                hashMap.put(num, hashMap.get(num) - 1);            }        }        int[] intResult = new int[result.size()];        for(int i = 0; i < result.size(); i++){            intResult[i] = result.get(i);        }        return intResult;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(nlog(n))$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路1时间复杂度-1"><a href="#思路1时间复杂度-1" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n)$</p><h3 id="思路1空间复杂度-1"><a href="#思路1空间复杂度-1" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:384.打乱数组</title>
      <link href="/2020/03/27/leetcode-384-da-luan-shu-zu/"/>
      <url>/2020/03/27/leetcode-384-da-luan-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-384-打乱数组"><a href="#Leetcode-384-打乱数组" class="headerlink" title="Leetcode: 384.打乱数组"></a><a href="https://leetcode-cn.com/problems/shuffle-an-array/" target="_blank" rel="noopener">Leetcode: 384.打乱数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>打乱一个没有重复元素的数组。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>// 以数字集合 1, 2 和 3 初始化数组。int[] nums = {1,2,3};Solution solution = new Solution(nums);// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。solution.shuffle();// 重设数组到它的初始状态[1,2,3]。solution.reset();// 随机返回数组[1,2,3]打乱后的结果。solution.shuffle();</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：复制数组-移除"><a href="#思路1：复制数组-移除" class="headerlink" title="思路1：复制数组+移除"></a>思路1：复制数组+移除</h3><p>复制一个新数组，然后随机置入数组，将置入数组的数移除</p><h3 id="思路2：Fisher–Yates-shuffle"><a href="#思路2：Fisher–Yates-shuffle" class="headerlink" title="思路2：Fisher–Yates shuffle"></a>思路2：Fisher–Yates shuffle</h3><p>遍历数组，随机化得到一个从当前位置到最后位置的数进行交换，该方法产生n!种可能，但是如果采用随机产生两个随机数则是错的，其产生的可能性为$n^n$,简单证明为n!可能不能被$n^n$整除</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1-复制数组-移除"><a href="#代码1-复制数组-移除" class="headerlink" title="代码1: 复制数组+移除"></a>代码1: 复制数组+移除</h3><pre class=" language-Java"><code class="language-Java">class Solution {    private int[] nums;    private int[] origins;    private Random rand = new Random();    public Solution(int[] nums) {        this.nums = nums;        origins = this.nums.clone();    }    /** Resets the array to its original configuration and return it. */    public int[] reset() {        this.nums = this.origins;        this.origins = this.origins.clone();        return this.nums;    }    /** Returns a random shuffling of the array. */    public int[] shuffle() {        List<Integer> copyList = new ArrayList<>();        for(int num: this.nums){            copyList.add(num);        }        for(int i = 0; i < this.nums.length; i++){            int removeIndex = rand.nextInt(copyList.size());            this.nums[i] = copyList.get(removeIndex);            copyList.remove(removeIndex);        }        return this.nums;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">class Solution {    private int[] nums;    private int[] origins;    private Random rand = new Random();    public Solution(int[] nums) {        this.nums = nums;        origins = this.nums.clone();    }    /** Resets the array to its original configuration and return it. */    public int[] reset() {        this.nums = this.origins;        this.origins = this.origins.clone();        return this.nums;    }    /** Returns a random shuffling of the array. */    public int[] shuffle() {        for(int i = 0; i < this.nums.length; i++){            int swapIndex = rand.nextInt(this.nums.length - i) + i;            int temp = this.nums[i];            this.nums[i] = this.nums[swapIndex];            this.nums[swapIndex] = temp;        }        return this.nums;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>$O(n^2)$</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$O(n)$没有了移除操作</p><h3 id="思路1空间复杂度-1"><a href="#思路1空间复杂度-1" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 数组 </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:283. 移动零</title>
      <link href="/2020/03/26/leetcode-283-yi-dong-ling/"/>
      <url>/2020/03/26/leetcode-283-yi-dong-ling/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-283-移动零"><a href="#Leetcode-283-移动零" class="headerlink" title="Leetcode:283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">Leetcode:283. 移动零</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-直接使用非零计数"><a href="#思路1-直接使用非零计数" class="headerlink" title="思路1: 直接使用非零计数"></a>思路1: 直接使用非零计数</h3><p>直接使用遍历加非零计数进行替换操作，然后对最后为零的填零</p><h3 id="思路2-非零计数-替换"><a href="#思路2-非零计数-替换" class="headerlink" title="思路2: 非零计数+替换"></a>思路2: 非零计数+替换</h3><p>思路1方法若在大量零的情况下需要遍历两次，所以可以考虑使用两个指针交换数据</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public void moveZeroes(int[] nums) {        if (nums == null || nums.length == 0){            return;        }        int notZeroIndex = 0;        for(int i = 0; i < nums.length; i++){            if (nums[i] != 0){                nums[notZeroIndex++] = nums[i];            }        }        for(int i = notZeroIndex; i < nums.length; i++){            nums[i] = 0;        }    }}</code></pre><h3 id="代码2：双指针-交换"><a href="#代码2：双指针-交换" class="headerlink" title="代码2：双指针+交换"></a>代码2：双指针+交换</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public void moveZeroes(int[] nums) {        if (nums == null || nums.length == 0){            return;        }        int notZeroIndex = 0;        for(int i = 0; i < nums.length; i++){            if(nums[i] != 0){                swap(nums, i, notZeroIndex++);            }        }    }    private void swap(int[] nums, int i, int j){        if (i == j){            return;        }        nums[i] = nums[i] + nums[j];        nums[j] = nums[i] - nums[j];        nums[i] = nums[i] - nums[j];    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1：直接使用非零计数"><a href="#思路1：直接使用非零计数" class="headerlink" title="思路1：直接使用非零计数"></a>思路1：直接使用非零计数</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(n)$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$O(1)$</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>同上，但是时间复杂度在最坏情况下要比思路1优</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
            <tag> 遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:217. 存在重复元素</title>
      <link href="/2020/03/26/leetcode-217-cun-zai-chong-fu-yuan-su/"/>
      <url>/2020/03/26/leetcode-217-cun-zai-chong-fu-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-217-存在重复元素"><a href="#Leetcode-217-存在重复元素" class="headerlink" title="Leetcode:217. 存在重复元素"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">Leetcode:217. 存在重复元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [1,2,3,1]输出: true</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [1,2,3,4]输出: false</code></pre><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例 3:"></a>示例 3:</h3><pre><code>输入: [1,1,1,3,3,4,3,2,4,2]输出: true</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-直接使用Hash"><a href="#思路1-直接使用Hash" class="headerlink" title="思路1: 直接使用Hash"></a>思路1: 直接使用Hash</h3><p>使用hashset对数据计数，若重复出现则直接返回true</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>###　代码１：直接使用Hash</p><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean containsDuplicate(int[] nums) {        if (nums == null || nums.length == 0){            return false;        }        Set<Integer> set = new HashSet<>();        for(int num: nums){            if (set.contains(num)){                return true;            } else{                set.add(num);            }        }        return false;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:189. 旋转数组</title>
      <link href="/2020/03/25/leetcode-189-xuan-zhuan-shu-zu/"/>
      <url>/2020/03/25/leetcode-189-xuan-zhuan-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-189-旋转数组"><a href="#Leetcode-189-旋转数组" class="headerlink" title="Leetcode:189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">Leetcode:189. 旋转数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-三次反转数组"><a href="#思路1-三次反转数组" class="headerlink" title="思路1: 三次反转数组"></a>思路1: 三次反转数组</h3><p>可以看作是首先将整个数组旋转，然后前k个元素反转，后nums.length - k个元素反转</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1-三次反转数组"><a href="#代码1-三次反转数组" class="headerlink" title="代码1: 三次反转数组"></a>代码1: 三次反转数组</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public void rotate(int[] nums, int k){        k = k % nums.length;        if (k == 0){            return;        }        reverse(nums, 0, nums.length - 1);        reverse(nums, 0, k-1);        reverse(nums, k, nums.length - 1);    }    private void reverse(int[] nums, int startIndex, int endIndex){        while(startIndex < endIndex){            int temp = nums[startIndex];            nums[startIndex++] = nums[endIndex];            nums[endIndex--] = temp;        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
            <tag> 反转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:152. 乘积最大子数组</title>
      <link href="/2020/03/24/leetcode-152-cheng-ji-zui-da-zi-shu-zu/"/>
      <url>/2020/03/24/leetcode-152-cheng-ji-zui-da-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子数组</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字）。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。</code></pre><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h3><pre><code>输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以维护两个DP,表示最大值和最小值（因为数据中包含正负),转移方程为$maxDP[i+1] = max(nums[i+1], maxDP[i+1]<em>nums[i+1], minDP[i+1]</em>nums[i+1])$以及$minDP[i+1] = min(nums[i+1], maxDP[i+1]<em>nums[i+1], minDP[i+1]</em>nums[i+1])$,由于只涉及DP的两个状态值，所以去除掉所有状态的存储，只存储上一状态即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">class Solution {    public int maxProduct(int[] nums) {        int result = nums[0];        int maxNum = 1;        int minNum = 1;        for(int i = 0; i < nums.length; i++){            if (nums[i] < 0){                maxNum = maxNum + minNum;                minNum = maxNum - minNum;                maxNum = maxNum - minNum;            }            maxNum = nums[i] > maxNum * nums[i] ? nums[i]: maxNum * nums[i];            minNum = nums[i] < minNum * nums[i] ? nums[i]: minNum * nums[i];            if(result < maxNum){                result = maxNum;            }        }        return result;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以使用多个DP过程存储中间可能状态</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> DP </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:344. 反转字符串</title>
      <link href="/2020/03/24/leetcode-344-fan-zhuan-zi-fu-chuan/"/>
      <url>/2020/03/24/leetcode-344-fan-zhuan-zi-fu-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-344-反转字符串"><a href="#Leetcode-344-反转字符串" class="headerlink" title="Leetcode:344. 反转字符串"></a><a href="https://leetcode-cn.com/explore/interview/card/top-interview-quesitons/275/string/1144/" target="_blank" rel="noopener">Leetcode:344. 反转字符串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接使用前后指针swap</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-Java"><code class="language-Java">class Solution {    public void reverseString(char[] s) {        if(s == null || s.length == 0){            return;        }        int left = 0;        int right = s.length - 1;        while (left < right){            char temp = s[left];            s[left++] = s[right];            s[right--] = temp;        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$O(n)$</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$O(1)$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:387. 字符串中的第一个唯一字符</title>
      <link href="/2020/03/23/leetcode-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu/"/>
      <url>/2020/03/23/leetcode-387-zi-fu-chuan-zhong-de-di-yi-ge-wei-yi-zi-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-387-字符串中的第一个唯一字符"><a href="#Leetcode-387-字符串中的第一个唯一字符" class="headerlink" title="Leetcode:387. 字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">Leetcode:387. 字符串中的第一个唯一字符</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</code></pre><h3 id="案例"><a href="#案例" class="headerlink" title="案例:"></a>案例:</h3><pre><code>s = &quot;leetcode&quot;返回 0.s = &quot;loveleetcode&quot;,返回 2.注意事项：您可以假定该字符串只包含小写字母。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路：数组-字典"><a href="#思路：数组-字典" class="headerlink" title="思路：数组 字典"></a>思路：数组 字典</h3><p>直接使用数组对字母计数二次遍历</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public int firstUniqChar(String s) {        if (s == null || s.length() == 0){            return -1;        }        int[] chDict = new int[26];        for(int i = 0; i < s.length(); i++){            chDict[s.charAt(i) - 'a'] += 1;        }        for(int i = 0; i < s.length(); i++){            if(chDict[s.charAt(i) - 'a'] == 1){                return i;            }        }        return -1;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:242. 有效的字母异位词</title>
      <link href="/2020/03/22/leetcode-242-you-xiao-de-zi-mu-yi-wei-ci/"/>
      <url>/2020/03/22/leetcode-242-you-xiao-de-zi-mu-yi-wei-ci/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-242-有效的字母异位词"><a href="#Leetcode-242-有效的字母异位词" class="headerlink" title="Leetcode:242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">Leetcode:242. 有效的字母异位词</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</code></pre><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h3><pre><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true示例 2:输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false说明:你可以假设字符串只包含小写字母。</code></pre><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶:"></a>进阶:</h3><pre><code>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-哈希表"><a href="#思路1-哈希表" class="headerlink" title="思路1: 哈希表"></a>思路1: 哈希表</h3><p>直接使用哈希表计数，先计算s的每个字母个数相加，然后计算t中个数相减</p><h3 id="思路2：数组-计数"><a href="#思路2：数组-计数" class="headerlink" title="思路2：数组+计数"></a>思路2：数组+计数</h3><p>鉴于只有26个字母，所以可以只用一个数组计数，解法可同上，但是常数空间消耗更少</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1：哈希表"><a href="#代码1：哈希表" class="headerlink" title="代码1：哈希表"></a>代码1：哈希表</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean isAnagram(String s, String t) {        if ((s == null && t != null) || (s != null && t == null) || s.length() != t.length()) {            return false;        }        Map<Character, Integer> chMap = new HashMap<>();        for(char ch: s.toCharArray()){            if (!chMap.containsKey(ch)){                chMap.put(ch, 1);            }            chMap.put(ch, chMap.get(ch) + 1);        }        for(char ch: t.toCharArray()){            if(!chMap.containsKey(ch) || chMap.get(ch) != 0){                return false;            } else{                chMap.put(ch, chMap.get(ch) - 1);            }        }        return true;    }}</code></pre><h3 id="代码2：数组-计数"><a href="#代码2：数组-计数" class="headerlink" title="代码2：数组+计数"></a>代码2：数组+计数</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean isAnagram(String s, String t) {        if ((s == null && t != null) || (s != null && t == null) || s.length() != t.length()) {            return false;        }        int[] count = new int[26];        for(int i=0; i < s.length(); i++){            count[s.charAt(i) - 'a'] += 1;            count[t.charAt(i) - 'a'] -= 1;        }        for(int i=0; i < 26; i++){            if(count[i] != 0){                return false;            }        }        return true;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>n</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>1,常数</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> easy </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 212: 单词搜索II</title>
      <link href="/2020/03/21/leetcode-212-dan-ci-sou-suo-ii/"/>
      <url>/2020/03/21/leetcode-212-dan-ci-sou-suo-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-212-单词搜索II"><a href="#Leetcode-212-单词搜索II" class="headerlink" title="Leetcode 212: 单词搜索II"></a><a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">Leetcode 212: 单词搜索II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个二维网格 board 和一个字典中的单词列表 words，找出所有同时在二维网格和字典中出现的单词。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>输入: words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[[&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],[&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],[&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],[&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]]输出: [&quot;eat&quot;,&quot;oath&quot;]说明:你可以假设所有输入都由小写字母 a-z 组成。</code></pre><h3 id="提示"><a href="#提示" class="headerlink" title="提示:"></a>提示:</h3><pre><code>你需要优化回溯算法以通过更大数据量的测试。你能否早点停止回溯？如果当前单词不存在于所有单词的前缀中，则可以立即停止回溯。什么样的数据结构可以有效地执行这样的操作？散列表是否可行？为什么？ 前缀树如何？如果你想学习如何实现一个基本的前缀树，请先查看这个问题： 实现Trie（前缀树）。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-回溯-DFS"><a href="#思路1-回溯-DFS" class="headerlink" title="思路1: 回溯+DFS"></a>思路1: 回溯+DFS</h3><p>直接使用回溯+DFS判断每个单词是否存在，需要注意一个单词不能使用两次以上一个字符。</p><h3 id="思路2-前缀树-回溯减枝"><a href="#思路2-前缀树-回溯减枝" class="headerlink" title="思路2: 前缀树+回溯减枝"></a>思路2: 前缀树+回溯减枝</h3><p>对所有的单词建立节点，然后回溯board中每个可能的单词，裁剪掉不能满足前缀树的路径</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1-回溯-DFS"><a href="#代码1-回溯-DFS" class="headerlink" title="代码1: 回溯+DFS"></a>代码1: 回溯+DFS</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public List<String> findWords(char[][] board, String[] words) {        List<String> result = new LinkedList<>();        if (words.length == 0 || board.length == 0 || board[0].length == 0){            return result;        }        for(String word: words){            if(hasWord(word, board)) {                result.add(word);            }        }        return result;    }    private boolean hasWord(String s, char[][] board){        boolean canFind = false;        for(int i = 0; i < board.length; i++){            for(int j = 0; j < board[0].length; j++){                if (s.charAt(0) == board[i][j] && wordDFS(s, board, 0, i, j)) {                    canFind = true;                    break;                }            }            if (canFind){                break;            }        }        return canFind;    }    private boolean wordDFS(String s, char[][] board, int startIndex, int i, int j){        if (startIndex == s.length() - 1){            return true;        }        boolean canFind = false;        char temp = s.charAt(startIndex);        char getCh = s.charAt(startIndex + 1);        board[i][j] = '$';        if(canGetCh(getCh, board, i + 1, j)){            canFind = canFind || wordDFS(s, board, startIndex+1, i+1, j);            if (canFind){                board[i][j] = temp;            }        }        if (!canFind && canGetCh(getCh, board, i -1, j)){            canFind = canFind || wordDFS(s, board, startIndex+1, i-1, j);            if (canFind){                board[i][j] = temp;            }        }        if (!canFind && canGetCh(getCh, board, i, j+1)){            canFind = canFind || wordDFS(s, board, startIndex+1, i, j+1);            if (canFind){                board[i][j] = temp;            }        }        if (!canFind && canGetCh(getCh, board, i, j-1)){            canFind = canFind || wordDFS(s, board, startIndex+1, i, j-1);            if (canFind){                board[i][j] = temp;            }        }        board[i][j] = temp;        return canFind;    }    private boolean canGetCh(char getCh, char[][] board, int i, int j){        if (i < 0 || i >= board.length || j < 0 || j >= board[0].length){            return false;        }        return board[i][j] == getCh;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1-时间复杂度"><a href="#思路1-时间复杂度" class="headerlink" title="思路1:时间复杂度"></a>思路1:时间复杂度</h3><p>只超过14%</p><h3 id="思路2-空间复杂度"><a href="#思路2-空间复杂度" class="headerlink" title="思路2:空间复杂度"></a>思路2:空间复杂度</h3><p>//TODO</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 回溯 </tag>
            
            <tag> Medium </tag>
            
            <tag> 前缀树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 208:实现Trie(前缀树)</title>
      <link href="/2020/03/20/leetcode-208-shi-xian-trie-qian-zhui-shu/"/>
      <url>/2020/03/20/leetcode-208-shi-xian-trie-qian-zhui-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-208-实现Trie-前缀树"><a href="#Leetcode-208-实现Trie-前缀树" class="headerlink" title="Leetcode 208:实现Trie(前缀树)"></a><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="noopener">Leetcode 208:实现Trie(前缀树)</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</code></pre><h3 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h3><pre><code>Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;);   // 返回 truetrie.search(&quot;app&quot;);     // 返回 falsetrie.startsWith(&quot;app&quot;); // 返回 truetrie.insert(&quot;app&quot;);   trie.search(&quot;app&quot;);     // 返回 true</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明:"></a>说明:</h3><pre><code>你可以假设所有的输入都是由小写字母 a-z 构成的。保证所有输入均为非空字符串。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-前缀树基本实现"><a href="#思路1-前缀树基本实现" class="headerlink" title="思路1: 前缀树基本实现"></a>思路1: 前缀树基本实现</h3><p>主要是使用前缀树的基本概念，将前缀字母连接到下一个后缀节点,以及标记好结束节点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><pre class=" language-Java"><code class="language-Java">class Trie {    private final int alphaSize = 26;    private Trie[] children = new Trie[alphaSize];    private boolean isEnd = false;    /** Initialize your data structure here. */    public Trie() {    }    /** Inserts a word into the trie. */    public void insert(String word) {        Trie temp = this;        for(var ch: word.toCharArray()){            if (temp.children[ch - 'a'] == null){                temp.children[ch - 'a'] = new Trie();            }            temp = temp.children[ch - 'a'];        }        temp.isEnd=true;    }    /** Returns if the word is in the trie. */    public boolean search(String word) {        Trie temp = this;        for(var ch: word.toCharArray()){            if (temp.children[ch - 'a'] == null){                return false;            }            temp = temp.children[ch - 'a'];        }        return temp.isEnd;    }    /** Returns if there is any word in the trie that starts with the given prefix. */    public boolean startsWith(String prefix) {        Trie temp = this;        for(var ch: prefix.toCharArray()){            if (temp.children[ch - 'a'] == null){                return false;            }            temp = temp.children[ch - 'a'];        }        return true;    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>$n$均可看作是链表的查找插入</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>$n$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 树 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 140: 单词切分II</title>
      <link href="/2020/03/19/leetcode-140-dan-ci-qie-fen-ii/"/>
      <url>/2020/03/19/leetcode-140-dan-ci-qie-fen-ii/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-140-单词切分II"><a href="#Leetcode-140-单词切分II" class="headerlink" title="Leetcode 140: 单词切分II"></a><a href="https://leetcode-cn.com/problems/word-break-ii/" target="_blank" rel="noopener">Leetcode 140: 单词切分II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</code></pre><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>分隔时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]输出:[&quot;cats and dog&quot;,&quot;cat sand dog&quot;]</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入:s = &quot;pineapplepenapple&quot;wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]输出:[&quot;pine apple pen apple&quot;,&quot;pineapple pen apple&quot;,&quot;pine applepen apple&quot;]解释: 注意你可以重复使用字典中的单词。</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入:s = &quot;catsandog&quot;wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出:[]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：DP-回溯"><a href="#思路1：DP-回溯" class="headerlink" title="思路1：DP+回溯"></a>思路1：DP+回溯</h3><p>即利用中等难度的dp单词切分获取到可能的子序列，根据是否可以整体切分以及切分标记回溯这些字序列获取最终的结果</p><h3 id="思路2-记忆回溯"><a href="#思路2-记忆回溯" class="headerlink" title="思路2: 记忆回溯"></a>思路2: 记忆回溯</h3><p>将每个位置i记为以他为起点，到最后结果的可能切分，最后递归求解。将每个位置记为(i, list<str>),减少无用的后缀计算，以空间换时间</p><h3 id="思路3：DP-直接记录"><a href="#思路3：DP-直接记录" class="headerlink" title="思路3：DP+直接记录"></a>思路3：DP+直接记录</h3><p>将每个位置直接记录可能的前缀串，最后得到记录的全单词切分前缀串。但是在leetcode上会出现内存分配过大而超时的现象，故意需要增加判断是否可以完全完成单词切分</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1-DP-回溯"><a href="#代码1-DP-回溯" class="headerlink" title="代码1: DP+回溯"></a>代码1: DP+回溯</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<String> wordBreak(String s, List<String> wordDict) {        List<String> result = new LinkedList<>();        if (s == null || s.length() == 0 || wordDict.size() == 0){            return result;        }        Set<String> hashSet = new HashSet<>(wordDict);        boolean[] dps = new boolean[s.length() + 1];        dps[0] = true;        for(int end=1; end < s.length() + 1; end++){            for(int start=0; start < end; start++) {                if(dps[start] && hashSet.contains(s.substring(start, end))) {                    dps[end] = true;                    break;                }            }        }        if (!dps[s.length()]) {            return result;        }        List<String> temp = new LinkedList<>();        wordBreakHelper(s, hashSet, s.length(), dps, temp, result);        return result;    }    private void wordBreakHelper(String s, Set<String> hashSet, int endIndex, boolean[] dps, List<String> temp, List<String> result) {        if (endIndex == 0) {            StringBuilder sb = new StringBuilder();            for(int i = temp.size() - 1; i >= 0; i--){                if (i != temp.size() - 1) {                    sb.append(" ");                }                sb.append(temp.get(i));            }            result.add(sb.toString());        }        for(int i=endIndex - 1; i >= 0; i--) {            if (dps[i] && hashSet.contains(s.substring(i, endIndex))){                temp.add(s.substring(i, endIndex));                wordBreakHelper(s, hashSet, i, dps, temp, result);                temp.remove(temp.size() - 1);            }        }    }}</code></pre><h3 id="代码2-记忆回溯"><a href="#代码2-记忆回溯" class="headerlink" title="代码2: 记忆回溯"></a>代码2: 记忆回溯</h3><pre class=" language-Java"><code class="language-Java">public class Solution2 {    Map<Integer, List<String>> hashMap = new HashMap<>();    public List<String> wordBreak(String s, List<String> wordDict){        List<String> result = new LinkedList<>();        if (s == null || s.length() == 0 || wordDict.size() == 0){            return result;        }        return wordBreakHelper(s, new HashSet<>(wordDict), 0);    }    private List<String> wordBreakHelper(String s, Set<String> hashSet, int startIndex) {        if (hashMap.containsKey(startIndex)) {            return hashMap.get(startIndex);        }        List<String> temp = new LinkedList<>();        // 标记是否可以完全切分        if (startIndex == s.length()) {            temp.add("");        }        for(int end=startIndex+1; end <= s.length(); end++){            if(hashSet.contains(s.substring(startIndex, end))){                List<String> list = wordBreakHelper(s, hashSet, end);                for(var l: list){                    if (l.equals("")){                        temp.add(s.substring(startIndex, end));                    } else{                        temp.add(s.substring(startIndex, end) + " " + l);                    }                }            }        }        hashMap.put(startIndex, temp);        return temp;    }}</code></pre><h3 id="代码3-DP-直接记录"><a href="#代码3-DP-直接记录" class="headerlink" title="代码3: DP+直接记录"></a>代码3: DP+直接记录</h3><pre class=" language-Java"><code class="language-Java">public class Solution3 {    public List<String> wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0 || wordDict.size() == 0 || !canWordBreak(s, wordDict)){            return new LinkedList<String>();        }        Set<String> hashSet = new HashSet<>(wordDict);        List<String>[] dps = new LinkedList[s.length() + 1];        List<String> zero = new LinkedList<>();        zero.add("");        dps[0] = zero;        for(int end=1; end <= s.length(); end++){            List<String> temp = new LinkedList<>();            for(int start=0; start < end; start++){                if (dps[start].size() > 0 && hashSet.contains(s.substring(start, end))){                    for(var l: dps[start]){                        temp.add(l + (l.equals("") ? "" : " ") + s.substring(start, end));                    }                }            }            dps[end] = temp;        }        return dps[s.length()];    }    public boolean canWordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if(wordDict.size() == 0) {            return false;        }        Set<String> hashSet = new HashSet<>(wordDict);        boolean[] dps = new boolean[s.length() + 1];        dps[0] = true;        for(int end = 1; end < s.length() + 1; end++) {            for(int start=0; start < end; start++) {                if (dps[start] && hashSet.contains(s.substring(start, end))) {                    dps[end] = true;                    break;                }            }        }        return dps[s.length()];    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1时间复杂度"><a href="#思路1时间复杂度" class="headerlink" title="思路1时间复杂度"></a>思路1时间复杂度</h3><p>相当于减枝之后$n^n$？</p><h3 id="思路1空间复杂度"><a href="#思路1空间复杂度" class="headerlink" title="思路1空间复杂度"></a>思路1空间复杂度</h3><p>$n$</p><h3 id="思路2时间复杂度"><a href="#思路2时间复杂度" class="headerlink" title="思路2时间复杂度"></a>思路2时间复杂度</h3><p>$n^3$</p><h3 id="思路2空间复杂度"><a href="#思路2空间复杂度" class="headerlink" title="思路2空间复杂度"></a>思路2空间复杂度</h3><p>$n^2$，相当于每次都清除</p><h3 id="思路3时间复杂度"><a href="#思路3时间复杂度" class="headerlink" title="思路3时间复杂度"></a>思路3时间复杂度</h3><p>$n^3$</p><h3 id="思路3空间复杂度"><a href="#思路3空间复杂度" class="headerlink" title="思路3空间复杂度"></a>思路3空间复杂度</h3><p>$n^3$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> Hard </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 139: 单词切分</title>
      <link href="/2020/03/19/leetcode-139-dan-ci-qie-fen/"/>
      <url>/2020/03/19/leetcode-139-dan-ci-qie-fen/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-139-单词切分"><a href="#Leetcode-139-单词切分" class="headerlink" title="Leetcode 139: 单词切分"></a><a href="https://leetcode-cn.com/problems/word-break/" target="_blank" rel="noopener">Leetcode 139: 单词切分</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><h3 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h3><pre><code>拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。</code></pre><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><pre><code>输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</code></pre><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><pre><code>输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。    注意你可以重复使用字典中的单词。</code></pre><h3 id="示例-3："><a href="#示例-3：" class="headerlink" title="示例 3："></a>示例 3：</h3><pre><code>输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：暴力遍历（时间爆表）"><a href="#思路1：暴力遍历（时间爆表）" class="headerlink" title="思路1：暴力遍历（时间爆表）"></a>思路1：暴力遍历（时间爆表）</h3><p>检查每一个前缀的子字符串回溯实现</p><h3 id="思路2：记忆化可切分后缀"><a href="#思路2：记忆化可切分后缀" class="headerlink" title="思路2：记忆化可切分后缀"></a>思路2：记忆化可切分后缀</h3><p>记录一个回溯记忆数组，若该后缀可切分则综合到最后可切分，这样可以大幅减少调用函数次数</p><h3 id="思路3-BFS实现"><a href="#思路3-BFS实现" class="headerlink" title="思路3: BFS实现"></a>思路3: BFS实现</h3><p>使用广度优先遍历实现，相当于将可到达相同的前缀节点合并，不进行相同的后续操作，减少函数调用次数。</p><h3 id="思路4-DP实现"><a href="#思路4-DP实现" class="headerlink" title="思路4: DP实现"></a>思路4: DP实现</h3><p>第j个位置可根据可形成前缀的位置进行计算，若其前缀为i,则若s.sub(i, j)在字典中则第j个位置为可拼接，最后一个位置即为最后是否可切分结果。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public boolean wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if (wordDict.size() == 0) {            return false;        }        HashSet<String> hashSet = new HashSet<>(wordDict);        return wordBreakHelper(s, 0, hashSet);    }    private boolean wordBreakHelper(String s, int startIndex, HashSet<String> hashSet) {        if (startIndex >= s.length()) {            return true;        }        boolean hasMatch = false;        for(var neededStr: hashSet) {//            System.out.println(s.substring(startIndex, startIndex + neededStr.length()));            if (startIndex + neededStr.length() <= s.length() && s.substring(startIndex, startIndex + neededStr.length()).equalsIgnoreCase(neededStr)) {                hasMatch = hasMatch || wordBreakHelper(s, startIndex + neededStr.length(), hashSet);                if (hasMatch) {                    break;                }            }        }        return hasMatch;    }}</code></pre><h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><pre class=" language-Java"><code class="language-Java">public class Solution2 {    public boolean wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if (wordDict.size() == 0) {            return false;        }        HashSet<String> hashSet = new HashSet<>(wordDict);        return wordBreakHelper(s, 0, hashSet, new Boolean[s.length()]);    }    private boolean wordBreakHelper(String neededStr, int startIndex, HashSet<String> hashSet, Boolean[] hasMatch) {        if (startIndex == neededStr.length()) {            return true;        }        if (hasMatch[startIndex] != null) {            return hasMatch[startIndex];        }        for(int i=startIndex + 1; i <= neededStr.length(); i++) {            if (hashSet.contains(neededStr.substring(startIndex, i)) && wordBreakHelper(neededStr, i, hashSet, hasMatch)) {                return hasMatch[startIndex] = true;            }        }        return hasMatch[startIndex] = false;    }}</code></pre><h3 id="代码3：BFS-（队列实现）"><a href="#代码3：BFS-（队列实现）" class="headerlink" title="代码3：BFS （队列实现）"></a>代码3：BFS （队列实现）</h3><pre class=" language-Java"><code class="language-Java">public class Solution3 {    public boolean wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if(wordDict.size() == 0) {            return false;        }        Set<String> hashSet = new HashSet<>(wordDict);        Queue<Integer> queue = new LinkedList<>();        boolean[] hasSeen = new boolean[s.length()];        queue.add(0);        while (!queue.isEmpty()) {            int startIndex = queue.remove();            if (!hasSeen[startIndex]) {                for(int endIndex = startIndex + 1; endIndex <= s.length(); endIndex++) {                    if (hashSet.contains(s.substring(startIndex, endIndex))) {                        queue.add(endIndex);                        if (endIndex == s.length()) {                            return true;                        }                    }                }                hasSeen[startIndex] = true;            }        }        return false;    }}</code></pre><h3 id="代码4-DP实现"><a href="#代码4-DP实现" class="headerlink" title="代码4: DP实现"></a>代码4: DP实现</h3><pre class=" language-Java"><code class="language-Java">public class Solution4 {    public boolean wordBreak(String s, List<String> wordDict) {        if (s == null || s.length() == 0) {            return true;        } else if(wordDict.size() == 0) {            return false;        }        Set<String> hashSet = new HashSet<>(wordDict);        boolean[] dps = new boolean[s.length() + 1];        dps[0] = true;        for(int end = 1; end < s.length() + 1; end++) {            for(int start=0; start < end; start++) {                if (dps[start] && hashSet.contains(s.substring(start, end))) {                    dps[end] = true;                    break;                }            }        }        return dps[s.length()];    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1：时间复杂度"><a href="#思路1：时间复杂度" class="headerlink" title="思路1：时间复杂度"></a>思路1：时间复杂度</h3><p>$n^n$</p><h3 id="思路1-空间复杂度"><a href="#思路1-空间复杂度" class="headerlink" title="思路1: 空间复杂度"></a>思路1: 空间复杂度</h3><p>$n$</p><h3 id="思路2-时间复杂度"><a href="#思路2-时间复杂度" class="headerlink" title="思路2: 时间复杂度"></a>思路2: 时间复杂度</h3><p>$n^2$</p><h3 id="思路2：空间复杂度"><a href="#思路2：空间复杂度" class="headerlink" title="思路2：空间复杂度"></a>思路2：空间复杂度</h3><p>$n$</p><h3 id="思路3-时间复杂度"><a href="#思路3-时间复杂度" class="headerlink" title="思路3: 时间复杂度"></a>思路3: 时间复杂度</h3><p>$n^2$</p><h3 id="思路3：空间复杂度"><a href="#思路3：空间复杂度" class="headerlink" title="思路3：空间复杂度"></a>思路3：空间复杂度</h3><p>$n$</p><h3 id="思路4-时间复杂度"><a href="#思路4-时间复杂度" class="headerlink" title="思路4: 时间复杂度"></a>思路4: 时间复杂度</h3><p>$n^2$</p><h3 id="思路4：空间复杂度"><a href="#思路4：空间复杂度" class="headerlink" title="思路4：空间复杂度"></a>思路4：空间复杂度</h3><p>$n$</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>重点在于如何将重复或者非必需的步骤省略</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 回溯 </tag>
            
            <tag> DP </tag>
            
            <tag> Medium </tag>
            
            <tag> BFS </tag>
            
            <tag> 标记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 131: 分割回文串</title>
      <link href="/2020/03/17/leetcode-131-fen-ge-hui-wen-chuan/"/>
      <url>/2020/03/17/leetcode-131-fen-ge-hui-wen-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-131-分割回文串"><a href="#Leetcode-131-分割回文串" class="headerlink" title="Leetcode 131: 分割回文串"></a>Leetcode 131: 分割回文串</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>输入: &quot;aab&quot;输出:[    [&quot;aa&quot;,&quot;b&quot;],    [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]]</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：-回溯-判断"><a href="#思路1：-回溯-判断" class="headerlink" title="思路1： 回溯+判断"></a>思路1： 回溯+判断</h3><p>即利用回溯思路不断增加是回文前缀字符串组的后续可能回文串</p><h3 id="思路1：代码"><a href="#思路1：代码" class="headerlink" title="思路1：代码"></a>思路1：代码</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public List<List<String>> partition(String s) {        List<List<String>> result = new LinkedList<>();        if (s.length() == 0) {            return result;        }        List<String> temp = new LinkedList<>();        partitionHelper(result, s, 0, temp);        return result;    }    private boolean canReverse(String s, int i, int j) {        if (i >= j) {            return true;        }        if (s.charAt(i++) == s.charAt(j--)) {            return canReverse(s, i, j);        } else {            return false;        }    }    private void partitionHelper(List<List<String>> res, String s, int startIndex, List<String> temp) {        int size = s.length();        if (size <= startIndex) {            res.add(new LinkedList<String>(temp));            return;        }        for(int i = startIndex; i < size; i++) {            if (canReverse(s, startIndex, i)) {                temp.add(s.substring(startIndex, i + 1));                partitionHelper(res, s, i + 1, temp);                temp.remove(temp.size() - 1);            }        }    }}</code></pre><h3 id="思路2：回溯-动态规划优化"><a href="#思路2：回溯-动态规划优化" class="headerlink" title="思路2：回溯+动态规划优化"></a>思路2：回溯+动态规划优化</h3><p>空间换时间，将判断是否是回文看成是一个动态规划，直接使用$n^2$算法求取，之后直接$1$调取</p><h3 id="思路2-代码"><a href="#思路2-代码" class="headerlink" title="思路2: 代码"></a>思路2: 代码</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public List<List<String>> partition(String s) {        List<List<String>> res = new LinkedList<List<String>>();        if (s.length() == 0) {            return res;        }        int size = s.length();        boolean[][] dps = new boolean[size][size];        for(int right = 0; right < size; right++) {            for(int left = 0; left <= right; left++) {                if (s.charAt(left) == s.charAt(right) && (right - left <= 2 || dps[left + 1][right - 1])) {                    dps[left][right] = true;                }            }        }        List<String> temp = new LinkedList<>();        partitionHelper(res, s, 0, temp, dps);        return res;    }    private void partitionHelper(List<List<String>> res, String s, int startIndex, List<String> temp, boolean[][] dps) {        int size = s.length();        if (startIndex >= size) {            res.add(new LinkedList<>(temp));            return;        }        for(int i = startIndex; i < size; i++) {            if (dps[startIndex][i]) {                temp.add(s.substring(startIndex, i + 1));                partitionHelper(res, s, i + 1, temp, dps);                temp.remove(temp.size() - 1);            }        }    }}</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$n*2^n?$</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$n*2^n?$</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$2^n + n^2$</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>$n * 2^n + n^2$</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Middle </tag>
            
            <tag> 回溯 </tag>
            
            <tag> DFS </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 25:验证回文串</title>
      <link href="/2020/03/12/leetcode-25-yan-zheng-hui-wen-chuan/"/>
      <url>/2020/03/12/leetcode-25-yan-zheng-hui-wen-chuan/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-25-验证回文串"><a href="#Leetcode-25-验证回文串" class="headerlink" title="Leetcode 25:验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">Leetcode 25:验证回文串</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>说明：本题中，我们将空字符串定义为有效的回文串。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1:"></a>示例 1:</h4><pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;输出: true</code></pre><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2:"></a>示例 2:</h4><pre><code>输入: &quot;race a car&quot;输出: false</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：双指针"><a href="#思路1：双指针" class="headerlink" title="思路1：双指针"></a>思路1：双指针</h3><p>使用头尾指针进行匹配，如头尾指针指向的字符不同则判为错,注意边界处理即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><pre class=" language-Java"><code class="language-Java">class Solution {    public boolean isPalindrome(String s) {        if (s == null || s.length() == 0) {            return true;        }        s = s.toLowerCase();        int low_index = 0;        int high_index= s.length() - 1;        boolean result = true;        while (true) {            while (high_index > low_index  && !isAlpha(s.charAt(low_index))) {                low_index ++;            }            while (high_index > low_index && !isAlpha(s.charAt(high_index))) {                high_index --;            }            if (high_index <= low_index) {                break;            }            else if (high_index > low_index && isAlpha(s.charAt(low_index)) && isAlpha(s.charAt(high_index)) && s.charAt(high_index) != s.charAt(low_index)) {                result = false;                break;            }            else{                high_index --;                low_index++;            }        }        return result;    }    private boolean isAlpha(char ch) {        if ((ch >= '0' && ch <= '9') || (ch  >= 'a' && ch <= 'z')) {            return true;        } else{            return false;        }    }}</code></pre><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><h3 id="思路1-1"><a href="#思路1-1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>n</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>1</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 887:鸡蛋掉落</title>
      <link href="/2020/03/09/leetcode-887-ji-dan-diao-luo/"/>
      <url>/2020/03/09/leetcode-887-ji-dan-diao-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode-887-鸡蛋掉落"><a href="#Leetcode-887-鸡蛋掉落" class="headerlink" title="Leetcode 887:鸡蛋掉落"></a><a href="https://leetcode-cn.com/problems/super-egg-drop/" target="_blank" rel="noopener">Leetcode 887:鸡蛋掉落</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。</p><p>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。</p><p>你知道存在楼层 F ，满足 0 &lt;= F &lt;= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。</p><p>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 &lt;= X &lt;= N）。</p><p>你的目标是确切地知道 F 的值是多少。</p><p>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？</p><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/super-egg-drop" target="_blank" rel="noopener">https://leetcode-cn.com/problems/super-egg-drop</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h4><pre><code>输入：K = 1, N = 2输出：2解释：鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。如果它没碎，那么我们肯定知道 F = 2 。因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。</code></pre><h4 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h4><pre><code>输入：K = 2, N = 6输出：3示例 3：输入：K = 3, N = 14输出：4</code></pre><h4 id="提示："><a href="#提示：" class="headerlink" title="提示："></a>提示：</h4><pre><code>1 &lt;= K &lt;= 1001 &lt;= N &lt;= 10000</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：基本二维DP-二分搜索"><a href="#思路1：基本二维DP-二分搜索" class="headerlink" title="思路1：基本二维DP + 二分搜索"></a>思路1：基本二维DP + 二分搜索</h3><p>直接二维DP计算最少的步骤，根据从x层掉落一个鸡蛋得到，则该情况下的状态转移方程为$DP[K][N] = max(DP[K][N-x], DP[K-1][x-1]) + 1$,从而可得到整体的状态转移方程$DP[K][N] = min(max(DP[K][N-x], DP[K-1][x-1])) + 1 x \isin [1, N]$,同时在dp过程中，前一个函数随x单调递减，后面单调递增，所以可以直接求是两个函数最接近的值作为候选求最小（可用两函数比相交（非整数，或者理解为值域相交，在相同定义域内））。所以该过程可用二分法求解。</p><h3 id="思路2：二维DP-逆向思维（根据步骤数和鸡蛋数求楼数）"><a href="#思路2：二维DP-逆向思维（根据步骤数和鸡蛋数求楼数）" class="headerlink" title="思路2：二维DP + 逆向思维（根据步骤数和鸡蛋数求楼数）"></a>思路2：二维DP + 逆向思维（根据步骤数和鸡蛋数求楼数）</h3><p>可理解为有3元的方程，在一定程度上可根据两元求第3个未知变量，根据题设可以得到一个楼层数与鸡蛋数和步骤的关系，即在特定步骤和鸡蛋数下最多可以测的层数。所以可以得到递推式M为步骤数，K为鸡蛋数，所以状态转移方程为$DP[M][K] = DP[M-1][K-1] + DP[M-1][K] + 1$，该方法考虑的是每增加一步，鸡蛋数增加或减少一个，加1相当于在当前层进行操作。状态初始化是可利用任何一个鸡蛋可探明层数为M层，任何1步K个鸡蛋都只能探明1层，在这个过程中K已知，所以可得到一个可定范围</p><h3 id="思路3：-逆向思维-推导函数-二分搜索"><a href="#思路3：-逆向思维-推导函数-二分搜索" class="headerlink" title="思路3： 逆向思维+推导函数 + 二分搜索"></a>思路3： 逆向思维+推导函数 + 二分搜索</h3><p>使用思路2进而推导出通项公式$f(k,n) = \frac{n(n-1)…(n-k)}{k!} + \frac{n(n-1)(n-2)}{3!} + \frac{n(n-1)}{2!} + n$,<a href="https://leetcode.com/problems/super-egg-drop/discuss/181702/Clear-C%2B%2B-codeRuntime-0-msO(1)-spacewith-explation.No-DPWhat-we-need-is-mathematical-thought!" target="_blank" rel="noopener">推导过程</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路1代码"><a href="#思路1代码" class="headerlink" title="思路1代码"></a>思路1代码</h3><pre class=" language-Java"><code class="language-Java">public class Solution {    public int superEggDrop(int K, int N) {        return eggDropHelper(K, N);    }    private static Map<String, Integer> eggDPs = new HashMap();    private String hasHelper(int K, int N) {        return Integer.toString(K) + "," + Integer.toString(N);    }    private int eggDropHelper(int K, int N) {        if (!eggDPs.containsKey(hasHelper(K, N))) {            int result = 0;            if (K == 1 || N == 0 || N == 1) {                result = N;            } else {                int low = 1;                int high = N;                while (low + 1 < high) {                    int mid = (low + high) / 2;                    int r1 = eggDropHelper(K, N - mid);                    int r2 = eggDropHelper(K - 1, mid - 1);                    if (r1 > r2) {                        low = mid;                    } else if (r1 < r2) {                        high = mid;                    } else {                        low = high = mid;                    }                }                result = 1 + Math.min(Math.max(eggDropHelper(K, N - low), eggDropHelper(K - 1, low - 1)),                        Math.max(eggDropHelper(K, N-high), eggDropHelper(K - 1, high - 1)));            }            eggDPs.put(hasHelper(K, N), result);        }        return eggDPs.get(hasHelper(K, N));    }}</code></pre><h3 id="思路2代码"><a href="#思路2代码" class="headerlink" title="思路2代码"></a>思路2代码</h3><pre class=" language-Java"><code class="language-Java">public class Solution2 {    public int superEggDrop(int K, int N) {        int ans = 0;        int[] dps = new int[K + 1];        for (int i = 0; i < K + 1; i ++) {            dps[i] = 0;        }        while (dps[K] < N) {            for(int i = K; i > 0; i--) {                dps[i] = 1 + dps[i - 1] + dps[i];            }            ans ++;        }        return ans;    }}</code></pre><h3 id="思路3代码"><a href="#思路3代码" class="headerlink" title="思路3代码"></a>思路3代码</h3><pre class=" language-Java"><code class="language-Java">public class Solution3 {    public int superEggDrop(int K, int N) {        int low = 1;        int high = N;        while (low < high) {            int mid = (low + high) / 2;            if (eggHelper(mid, K, N) < N) {                low = mid + 1;            } else {                high = mid;            }        }        return low;    }    private int eggHelper(int mid, int K, int N) {        int result = 0;        int r = 1;        for (int i = 1; i <= K; i++) {            r *= mid - i + 1;            r /= i;            result += r;            if (result > N) break;        }        return result;    }}</code></pre><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>kNlog(N)</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>N * N</p><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><h4 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>Klog(N)</p><h4 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>N</p><h3 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h3><h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>Klog(N)</p><h4 id="空间复杂度-2"><a href="#空间复杂度-2" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>1</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode:169. 多数元素</title>
      <link href="/2020/03/05/leetcode-169-duo-shu-yuan-su/"/>
      <url>/2020/03/05/leetcode-169-duo-shu-yuan-su/</url>
      
        <content type="html"><![CDATA[<h1 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>示例1：    输入: [3,2,3]    输出: 3示例2:    输入: [2,2,1,1,1,2,2]    输出: 2</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1：hash"><a href="#思路1：hash" class="headerlink" title="思路1：hash"></a>思路1：hash</h3><p>使用hash表存储&lt;num, numCount&gt;数与数出现次数，如果数超过⌊ n/2 ⌋，则该数为众数</p><h3 id="思路2-Boyer-Moore-投票算法"><a href="#思路2-Boyer-Moore-投票算法" class="headerlink" title="思路2: Boyer-Moore 投票算法"></a>思路2: Boyer-Moore 投票算法</h3><p>直接使用计数标记，记录好候选的最多元素，然后因为多数元素超过一半，所以可以不断使用count计数完成候选元素替换、增加、减小。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">majorityElement</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> result<span class="token punctuation">)</span><span class="token punctuation">{</span>                count <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>                count <span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    result <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                    count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>思路1和思路2都是n</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>思路1会额外有n的字典，思路2不占用新的空间</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数组 </tag>
            
            <tag> 计数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 240:搜索二维矩阵II</title>
      <link href="/2020/03/05/leetcode-240/"/>
      <url>/2020/03/05/leetcode-240/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索二维矩阵II"><a href="#搜索二维矩阵II" class="headerlink" title="搜索二维矩阵II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/" target="_blank" rel="noopener">搜索二维矩阵II</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><pre><code>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：每行的元素从左到右升序排列。每列的元素从上到下升序排列。</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>现有矩阵 matrix 如下：    [        [1,   4,  7, 11, 15],        [2,   5,  8, 12, 19],        [3,   6,  9, 16, 22],        [10, 13, 14, 17, 24],        [18, 21, 23, 26, 30]    ]给定 target = 5，返回 true。给定 target = 20，返回 false。</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-暴力法"><a href="#思路1-暴力法" class="headerlink" title="思路1 暴力法"></a>思路1 暴力法</h3><p>直接二维数组遍历</p><h3 id="思路2-按照已有顺序遍历"><a href="#思路2-按照已有顺序遍历" class="headerlink" title="思路2: 按照已有顺序遍历"></a>思路2: 按照已有顺序遍历</h3><p>按照题目给的信息，则可根据原数组的排序方式，设置index从数组第一行最后一列元素开始遍历，这样以m+n的算法复杂度得出结果</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="思路2：代码"><a href="#思路2：代码" class="headerlink" title="思路2：代码"></a>思路2：代码</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">searchMatrix</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> matrix<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>matrix <span class="token operator">==</span> null <span class="token operator">||</span> matrix<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> matrix<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> columns <span class="token operator">=</span> matrix<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span> rowIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> colIndex <span class="token operator">=</span> columns <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> result <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>rowIndex <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> colIndex <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>rowIndex <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> colIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>rowIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>colIndex<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                colIndex <span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>rowIndex <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> colIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> matrix<span class="token punctuation">[</span>rowIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>colIndex<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                rowIndex <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rowIndex <span class="token operator">&lt;</span> rows <span class="token operator">&amp;&amp;</span> colIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> target <span class="token operator">==</span> matrix<span class="token punctuation">[</span>rowIndex<span class="token punctuation">]</span><span class="token punctuation">[</span>colIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="总结体会"><a href="#总结体会" class="headerlink" title="总结体会"></a>总结体会</h2><p>在实现过程中需要注意下标溢出</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 遍历 </tag>
            
            <tag> 边界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 32:最长有效括号</title>
      <link href="/2020/03/04/leetcode-32/"/>
      <url>/2020/03/04/leetcode-32/</url>
      
        <content type="html"><![CDATA[<h1 id="最长有效括号"><a href="#最长有效括号" class="headerlink" title="最长有效括号"></a><a href="https://leetcode-cn.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">最长有效括号</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个只包含 ‘(‘ 和 ‘)’ 的字符串，找出最长的包含有效括号的子串的长度。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1:"></a>示例1:</h3><pre><code>输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot;</code></pre><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2:"></a>示例2:</h3><pre><code>输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot;</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1-DP-Stack"><a href="#思路1-DP-Stack" class="headerlink" title="思路1 DP + Stack"></a>思路1 DP + Stack</h3><p>存在括号匹配可用栈进行存储，寻找满足括号对的存在，但是在本题中光有匹配的数目是不够的，需要从整体上计算匹配上的括号数目，且存在括号包含和括号不包含两种情况，如果非包含关系的话可以使用DP思想将匹配好的为止进行存储</p><h3 id="思路2-Stack"><a href="#思路2-Stack" class="headerlink" title="思路2 Stack"></a>思路2 Stack</h3><p>其实与思路1类似可以直接只是用栈作为容器完成程序，主要在于满足匹配的最长子串的”)”开始索引，然后使用最后匹配的”)”进行位置计算，“(”和中间”)”全部pop,注意的关键点在于初始化栈是将-1引入为第一个元素，充当于”)”</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="源文件"><a href="#源文件" class="headerlink" title="源文件"></a>源文件</h4><h4 id="DP-Stack"><a href="#DP-Stack" class="headerlink" title="DP + Stack"></a>DP + Stack</h4><ul><li>Java<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestValidParentheses</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dps <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> matchIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> curLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      Stack<span class="token operator">&lt;</span>Integer<span class="token operator">></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">char</span> newChar <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>newChar <span class="token operator">==</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">else</span><span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  matchIndex <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  curLength <span class="token operator">=</span> i <span class="token operator">-</span> matchIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>matchIndex <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      curLength <span class="token operator">+=</span> dps<span class="token punctuation">[</span>matchIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  dps<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> curLength<span class="token punctuation">;</span>                  <span class="token keyword">if</span> <span class="token punctuation">(</span>curLength <span class="token operator">></span> result<span class="token punctuation">)</span> <span class="token punctuation">{</span>                      result <span class="token operator">=</span> curLength<span class="token punctuation">;</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>Python<pre class=" language-Python"><code class="language-Python">class Solution:  def longestValidParentheses(self, s: str) -> int:      dp = [0, ] * len(s)      result = 0      cache = []      for i in range(0, len(s)):          cur_char = s[i]          if cur_char == '(':              cache.append(i)          else:              if len(cache) == 0:                  continue              else:                  match_index = cache.pop()                  cur_len = i - match_index + 1                  if match_index - 1 > 0:                      cur_len += dp[match_index - 1]                  dp[i] = cur_len                  if cur_len > result:                      result = cur_len      return result</code></pre><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4></li><li>Java <pre class=" language-Java"><code class="language-Java">public class Solution2 {  public int longestValidParentheses(String s) {      if (s == null || s.length() < 2) {          return 0;      }      Stack<Integer> stack = new Stack<>();      stack.push(-1);      int result = 0;      int tmp = 0;      for (int i = 0; i < s.length(); i ++) {          if (s.charAt(i) == '(') {              stack.push(i);          } else {              stack.pop();              if (stack.isEmpty()) {                  stack.push(i);              } else {                  tmp = i - stack.peek();                  result = result > tmp ? result : tmp;              }          }      }      return result;  }}</code></pre><h2 id="实验效果分析"><a href="#实验效果分析" class="headerlink" title="实验效果分析"></a>实验效果分析</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><h4 id="Stack-DP"><a href="#Stack-DP" class="headerlink" title="Stack + DP"></a>Stack + DP</h4>$n$<h4 id="Stack-1"><a href="#Stack-1" class="headerlink" title="Stack"></a>Stack</h4>$n$<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><h4 id="Stack-DP-1"><a href="#Stack-DP-1" class="headerlink" title="Stack + DP"></a>Stack + DP</h4>$2n$<h4 id="Stack-2"><a href="#Stack-2" class="headerlink" title="Stack"></a>Stack</h4>$n$</li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Hard </tag>
            
            <tag> DP </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAE：Rank+(预训练+GNN联合训练)</title>
      <link href="/2020/03/04/sae-yue-du/"/>
      <url>/2020/03/04/sae-yue-du/</url>
      
        <content type="html"><![CDATA[<h1 id="SAE：rank-预训练-GNN联合训练"><a href="#SAE：rank-预训练-GNN联合训练" class="headerlink" title="SAE：rank+(预训练+GNN联合训练)"></a>SAE：rank+(预训练+GNN联合训练)</h1><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="https://arxiv.org/pdf/1911.00484.pdf" target="_blank" rel="noopener">Select, Answer and Explain: Interpretable Multi-hop Reading Comprehension over Multiple Documents</a></p><h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>首先Multi-Head Attention以Rank方式挑选问题相关文章，然后使用预训练模型得到Span信息 + GNN获取支撑句以及回答类型的联合训练的方式得到最终阅读理解的答案以及解释。</p><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><p>构建目前阅读理解通用流程，并在各个流程中提出自己的优化方法。首先通过对比排序的方式过滤掉答案无关段落，然后通过答案预测任务和支撑句预测任务联合训练得到最终的结果。</p><h3 id="实现亮点"><a href="#实现亮点" class="headerlink" title="实现亮点"></a>实现亮点</h3><ol><li>使用Multi-Head Attention实现对段落的rank<br><img src="https://i.loli.net/2020/03/04/txmFIgXZ8S6quar.png" alt="document_selector.png"><br>rank策略是为段落设定不同的rank值，如果段落为支撑句则rank值为1，若段落包含答案则rank值为2，其余为零。在训练过程中使用句对比较使用Multi-Head Attention进行训练。然后取top k相关段落。</li><li>使用GNN得到支撑句以及答案类型<br><img src="https://i.loli.net/2020/03/04/jFKb8pgYSdMVTCq.png" alt="sup_type_gnn.png"><br>将BERT编码后的Sentence节点输入到GNN中，然后使用GCN的训练策略达到图平衡。然后对平衡后的节点接两层感知机进行支撑句预测，同时使用支撑句label+graph attention+两层感知机的方式获取答案类型</li><li>将span预测、支撑句和答案类型预测联合训练<br><img src="https://i.loli.net/2020/03/04/YDywU7eLtdIcbmp.png" alt="answer_span_sup.png"><br>以上图的方式获得答案span，然后加上上个亮点的支撑段落抽取以及答案类型判断获取联合损失进行训练。<br>$$ L = \gamma L^{span} + BCE(\hat{y}^{sp}, y^{sp}) + CE(\hat{y}^{ans}, y^{ans}) $$<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3>在HotpotQA的非开放域的数据集上实现次SOTA(截止该文章发表)<h4 id="消融实验分析"><a href="#消融实验分析" class="headerlink" title="消融实验分析"></a>消融实验分析</h4></li></ol><ul><li>整体分析<br><img src="https://i.loli.net/2020/03/04/WbyeoSvV7dGU4uP.png" alt="compare.png"><br>整体上比上一轮顶会方法效果提升绝对值较大</li><li>段落挑选分析<br><img src="https://i.loli.net/2020/03/04/LTfGYwjOiI9h75M.png" alt="selector_compare.png"><br>加上支撑段落挑选之后最终效果提升有3%~4%,但是在挑选支撑段落上加上MHSA EM可以提升15%+，该方法提升效果还是很明显的，rank的好处:smile:</li><li>GNN实现效果分析<br><img src="https://i.loli.net/2020/03/04/Jg6PvsA4mZj3YXl.png" alt="gnn_compare.png"><br>从实验来看是否从一个段落中的节点边最有效，有问题实体边以及相同实体效果替身不是很明显 :s。整体来看提升1.4%,提升较小，但是同样重点使用GNN的<a href="https://arxiv.org/pdf/1911.03631.pdf" target="_blank" rel="noopener">HGN</a>提升较大,分层GNN赛高<h3 id="细节发现"><a href="#细节发现" class="headerlink" title="细节发现"></a>细节发现</h3></li><li>在进行段落挑选时选用2效果较好，和齐鹏的<a href="https://arxiv.org/pdf/1910.07000.pdf" target="_blank" rel="noopener">GoldEn Retriever</a>定的参数一样:joy:</li><li>在最后预测时答案和答案类型使用的是两层多层感知机，而是否是支撑段落使用的一层感知机。炼丹++ :s<h2 id="开源可复现"><a href="#开源可复现" class="headerlink" title="开源可复现"></a>开源可复现</h2><h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3>无<h3 id="复现效果"><a href="#复现效果" class="headerlink" title="复现效果"></a>复现效果</h3>无</li></ul>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文阅读 </tag>
            
            <tag> 阅读理解 </tag>
            
            <tag> NLP </tag>
            
            <tag> HotpotQA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HotpotQA分析</title>
      <link href="/2019/12/09/hotpotqa-fen-xi/"/>
      <url>/2019/12/09/hotpotqa-fen-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="HotpotQA分析"><a href="#HotpotQA分析" class="headerlink" title="HotpotQA分析"></a>HotpotQA分析</h1><h2 id="数据说明"><a href="#数据说明" class="headerlink" title="数据说明"></a>数据说明</h2><p><a href="https://arxiv.org/pdf/1809.09600.pdf" target="_blank" rel="noopener">HOTPOTQA: A Dataset for Diverse, Explainable<br>Multi-hop Question Answering</a></p><h2 id="简单数据分析"><a href="#简单数据分析" class="headerlink" title="简单数据分析"></a>简单数据分析</h2><h3 id="数据样例"><a href="#数据样例" class="headerlink" title="数据样例"></a>数据样例</h3><p><img src="https://i.loli.net/2019/12/09/Xru7oOWUNjbLk1M.png" alt="数据样例.png"></p><h3 id="答案长度分布"><a href="#答案长度分布" class="headerlink" title="答案长度分布"></a>答案长度分布</h3><p><img src="https://i.loli.net/2019/12/09/Xru7oOWUNjbLk1M.png" alt="答案长度分布.png"></p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读理解 </tag>
            
            <tag> 数据集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Attention详细解析</title>
      <link href="/2019/12/08/attention-xiang-xi-jie-xi/"/>
      <url>/2019/12/08/attention-xiang-xi-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="Attention机制理解"><a href="#Attention机制理解" class="headerlink" title="Attention机制理解"></a>Attention机制理解</h1><h2 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h2><p><a href="https://zhuanlan.zhihu.com/p/47063917" target="_blank" rel="noopener">Attention机制详解（一）——Seq2Seq中的Attention</a></p><h2 id="Attention提出理由"><a href="#Attention提出理由" class="headerlink" title="Attention提出理由"></a>Attention提出理由</h2><h3 id="解决痛点"><a href="#解决痛点" class="headerlink" title="解决痛点"></a>解决痛点</h3><p>在传统的机器翻译中采用encoder-decoder结构，encoder将输入的句子将其转换为定长的向量，然后decoder将向量转化为目标文字。且通常是encoder将最后一层hidden vector作为decoder的起始，然后通过decoder翻译为其他语言。这其中会由于RNN自身特性带来长程梯度消失和并行化差的问题。其中较长的句子也较难在最后的vector中保存需要的有效信息</p><h3 id="提出解决方案"><a href="#提出解决方案" class="headerlink" title="提出解决方案"></a>提出解决方案</h3><p>模拟人翻译的过程，当翻译部分词时将注意力或者更多的注意力放在需要关注的词上，通过类似于赋权的方式计算每个输入位置j与输出位置的关联性。例如可以计算每个输入位置j和当前输出位置的关联性$e_{tj} = a(s_{t-1}, h_j)$,所以写成向量形式就可以得到$\stackrel{-&gt;}{e_t} = (a(s_{t-1}, h_1), …, a(s_{t-1}, h_T))$ $a$是一种相关性的算符，常见的有点乘形式$\stackrel{-&gt;}{e_t}=\stackrel{-&gt;}{s_{t-1}}^T\stackrel{-&gt;}{h}$,加权点乘$\stackrel{-&gt;}{s_{t-1}}^TW\stackrel{-&gt;}{h}$, 加和$\stackrel{-&gt;}{v}^Ttanh(W_1\stackrel{-&gt;}{h} + W_2\stackrel{-&gt;}{s_{t - 1}})$,然后$\stackrel{-&gt;}{s_{t - 1}}$进行softmax操作将normalize得到attention的分布</p><h3 id="self-attention提出原因"><a href="#self-attention提出原因" class="headerlink" title="self-attention提出原因"></a>self-attention提出原因</h3><p>尽可能的去除RNNs网络结构，解决RNN由于其顺序结构进行训练，训练速度会受到约束。在RNN中需要处理对句子中的词一步步地进行顺序处理，并且当它们相距较远时候效果较差。Self-Attention利用了Attention的机制，计算每个单词和其他所有单词之间的关联。可以更好地考虑上下文的信息</p><h3 id="Transformer整体结构解析"><a href="#Transformer整体结构解析" class="headerlink" title="Transformer整体结构解析"></a>Transformer整体结构解析</h3><p>使用Multi-head Attention将多个Self-Attention结构结合，每个head会学习到不同的表征，给模型更大的容量</p><h3 id="Self-Attention详细解析"><a href="#Self-Attention详细解析" class="headerlink" title="Self-Attention详细解析"></a>Self-Attention详细解析</h3><p>Self-Attention基本结构如下<img src="./scaled_dot_product_attention.jpg" alt="avatar"></p><h4 id="对于Self-Attention的利用"><a href="#对于Self-Attention的利用" class="headerlink" title="对于Self-Attention的利用"></a>对于Self-Attention的利用</h4><p>对于Self-Attention来说使用来自一个输入的Q(Query)、K(Key)、V(value)进行计算。首先计算Q与K之间的点乘，然后防止其结果过大，除以一个尺度标度$\sqrt{d_k}$,其中$d_k$为一个query和key向量的维度。再利用Softmax将其结果归一化为概率分布，然后再乘以矩阵V就得到权重求和的表示。该操作表示为$Attention(Q, K, V)=softmax(QK^T\div\sqrt{d_k})V$,其中Q,K,V都是通过输入向量进行矩阵运算得到。有一个可视化较好的<a href="https://zhuanlan.zhihu.com/p/47282410" target="_blank" rel="noopener">解释</a>。需要注意的点是，在类似于encoder和decoder的第一层中q,k,v都是使用来自前一层的decoder的输出，但是在decoder的第二层使用的是来自q是来自encoder的输出，k,v是来自decoder的第一层结果。同时在decoder中使用的不是单纯的Multi-Head Attention而是使用了Masked Multi-Head Attention（因为在翻译过程中不知道后面的输入?)。</p><h4 id="其他结构"><a href="#其他结构" class="headerlink" title="其他结构"></a>其他结构</h4><p>使用了Positional Encoding，该方法主要是将模型没有recurrence和convolution的结构导致没够关于单词在源句子中的位置或绝对的信息，为了让模型更好地学习位置信息的产物，Transformer是使用了三角函数的方式进行encoding。同时在每一步的Multi-Head Attention之后使用了Add和Normanize操作，其中Add表示Residual Connection,该方法是为了解决多层网络训练困难的问题，通过将前一层的信息无差地传递到下一层，可以有效的关注差异部分，这一方法之前在ResNet等图像处理中经常被使用到。而Norm是代表Layer Normalization，该方法通过对层的激活值得归一化，加速模型的训练过程，使得模型可以更快地收敛<a href="https://arxiv.org/pdf/1607.06450.pdf" target="_blank" rel="noopener">Layer Normalization</a></p><h2 id="Attention模型的应用"><a href="#Attention模型的应用" class="headerlink" title="Attention模型的应用"></a>Attention模型的应用</h2><h3 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h3><h4 id="创造新的结构Universal-Transformers"><a href="#创造新的结构Universal-Transformers" class="headerlink" title="创造新的结构Universal Transformers"></a>创造新的结构Universal Transformers</h4><p><a href="https://arxiv.org/pdf/1807.03819.pdf" target="_blank" rel="noopener">Universal Transformers</a><br><br>该文章结合了Transformer结构和RNN循环归纳的优点，使得Transformer结构能够适用更多自然语言理解的问题。</p><h4 id="创造新的预训练模型Bert等"><a href="#创造新的预训练模型Bert等" class="headerlink" title="创造新的预训练模型Bert等"></a>创造新的预训练模型Bert等</h4><p><a href="https://arxiv.org/pdf/1810.04805.pdf" target="_blank" rel="noopener">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a><br><br>使用双向的Transformer进行预处理，得到包含有上下文信息的表征，根据表征可以fine-tune很多自然语言处理任务，对于GLUE Benchmark(主要包含MNLI,RTE：比较两个句子的语义关系，QQP：判别Quora上两个问题相似度，QNLI：问答，SST-2：情感分析，CoLA:语句合理性判别，STS-B, MRPC：句子相似度判别)，SQuAD(问答)，NER（命名实体识别）等都有极大的提高.</p><h4 id="文本生成"><a href="#文本生成" class="headerlink" title="文本生成"></a>文本生成</h4><p><a href="https://arxiv.org/abs/1801.10198.pdf" target="_blank" rel="noopener">Generating Wikipedia by Summarizing Long Sequences</a></p><h3 id="图像处理及合成"><a href="#图像处理及合成" class="headerlink" title="图像处理及合成"></a>图像处理及合成</h3><h4 id="Attention利用始祖"><a href="#Attention利用始祖" class="headerlink" title="Attention利用始祖"></a>Attention利用始祖</h4><p><a href="https://arxiv.org/abs/1502.03044" target="_blank" rel="noopener">Show, Attend and Tell: Neural Image Caption Generation with Visual Attention</a><br><br>利用Attention机制进行Image Caption(将图像翻译为文字表述)</p><h4 id="文本合成和超分使用"><a href="#文本合成和超分使用" class="headerlink" title="文本合成和超分使用"></a>文本合成和超分使用</h4><p><a href="https://arxiv.org/abs/1802.05751" target="_blank" rel="noopener">Image Transformer</a><br><br>可以使用Attention机制对图像进行合成，例如将局部图像进行补全，也可以将低分辨率的图像还原高分辨率的图像。同时由于Image Transformer模型训练的稳定性，可能和GAN有抗衡之势</p><h3 id="其他领域结合"><a href="#其他领域结合" class="headerlink" title="其他领域结合"></a>其他领域结合</h3><h4 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h4><p><a href="https://arxiv.org/pdf/1711.04725.pdf" target="_blank" rel="noopener">Neural Attentive Session-based Recommendation</a><br><br>利用Attention模型处理用户sesstion中的序列信息进行相关推荐</p><h4 id="音乐生成"><a href="#音乐生成" class="headerlink" title="音乐生成"></a>音乐生成</h4><p><a href="">Generating Long-Term Structure in Songs and Stories</a><br><br>使用Attention RNN创作乐曲</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attention </tag>
            
            <tag> BERT </tag>
            
            <tag> 网络结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNC多粒度支撑段落和支撑句</title>
      <link href="/2019/12/08/unc-duo-li-du-zhi-cheng-duan-luo-he-zhi-cheng-ju/"/>
      <url>/2019/12/08/unc-duo-li-du-zhi-cheng-duan-luo-he-zhi-cheng-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="UNC多粒度支撑段落和支撑句"><a href="#UNC多粒度支撑段落和支撑句" class="headerlink" title="UNC多粒度支撑段落和支撑句"></a>UNC多粒度支撑段落和支撑句</h1><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="https://arxiv.org/pdf/1909.08041.pdf" target="_blank" rel="noopener">Revealing the Importance of Semantic Retrieval<br>for Machine Reading at Scale</a></p><h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>通过term按照文本相关性搜索到可靠数量的段落，然后通过神经网络模型召回支撑段落，然后再在支撑段落里召回支撑句，并且文章做了大量的消融实验证明了支撑段落具有重大意义，支撑句需要有一些噪音效果才比较好。</p><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h2 id="开源可复现"><a href="#开源可复现" class="headerlink" title="开源可复现"></a>开源可复现</h2><p>开源</p><h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3><p><a href="easonnie/semanticRetrievalMRS">easonnie/semanticRetrievalMRS</a></p><h3 id="复现效果"><a href="#复现效果" class="headerlink" title="复现效果"></a>复现效果</h3><p>无</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文阅读 </tag>
            
            <tag> IR </tag>
            
            <tag> 信息检索 </tag>
            
            <tag> hotpotqa </tag>
            
            <tag> emnlp </tag>
            
            <tag> 2019 </tag>
            
            <tag> multi-hot </tag>
            
            <tag> 消融实验 </tag>
            
            <tag> 需要精读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微软实验室HGN分层图网络</title>
      <link href="/2019/12/08/wei-ruan-shi-yan-shi-hgn-fen-ceng-tu-wang-luo/"/>
      <url>/2019/12/08/wei-ruan-shi-yan-shi-hgn-fen-ceng-tu-wang-luo/</url>
      
        <content type="html"><![CDATA[<h1 id="微软实验室HGN分层图网络"><a href="#微软实验室HGN分层图网络" class="headerlink" title="微软实验室HGN分层图网络"></a>微软实验室HGN分层图网络</h1><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="https://arxiv.org/pdf/1911.03631.pdf" target="_blank" rel="noopener">Hierarchical Graph Network for Multi-hop Question Answering</a></p><h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>使用图神经网络实现段落、句子、实体关联加入到多步问答中，做了大量消融实验，包含各个层之间的消融以及不同预训练模型的消融</p><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h2 id="开源可复现"><a href="#开源可复现" class="headerlink" title="开源可复现"></a>开源可复现</h2><p>非开源</p><h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3><p>无</p><h3 id="复现效果"><a href="#复现效果" class="headerlink" title="复现效果"></a>复现效果</h3><p>无</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读理解 </tag>
            
            <tag> 图神经网络 </tag>
            
            <tag> 多层图神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建</title>
      <link href="/2019/12/08/blog-builder/"/>
      <url>/2019/12/08/blog-builder/</url>
      
        <content type="html"><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://godweiyang.com/about/" target="_blank" rel="noopener">韦阳的博客</a></p><h2 id="实际使用主题"><a href="#实际使用主题" class="headerlink" title="实际使用主题"></a>实际使用主题</h2><p><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a></p><h2 id="主题目前特色实现功能"><a href="#主题目前特色实现功能" class="headerlink" title="主题目前特色实现功能"></a>主题目前特色实现功能</h2><ul><li>标签和分类</li><li>文档搜索</li><li>gittalk集成</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答</title>
      <link href="/2019/12/08/si-tan-fu-nlp-qi-peng-duo-bu-wen-ti-sheng-cheng-shi-xian-hotpotqa-kai-fang-yu-wen-da/"/>
      <url>/2019/12/08/si-tan-fu-nlp-qi-peng-duo-bu-wen-ti-sheng-cheng-shi-xian-hotpotqa-kai-fang-yu-wen-da/</url>
      
        <content type="html"><![CDATA[<h1 id="斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答"><a href="#斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答" class="headerlink" title="斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答"></a>斯坦福NLP齐鹏多步问题生成实现hotpotqa开放域问答</h1><h2 id="论文地址"><a href="#论文地址" class="headerlink" title="论文地址"></a>论文地址</h2><p><a href="https://arxiv.org/pdf/1910.07000.pdf" target="_blank" rel="noopener">Answering Complex Open-domain Questions Through Iterative Query Generation</a></p><h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>使用启发式的方法进行多步问题的细粒度化，在召回量较少的情况下得到高准确率的支撑文档，进而提高开放域问答的效果，并完成一个完整的Pipeline的工作,其中包含很多小技巧，包含在Content和question编码的时候使用0、1而不是cls/sep，提高实验基线。</p><h2 id="论文精读"><a href="#论文精读" class="headerlink" title="论文精读"></a>论文精读</h2><h3 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h3><h2 id="开源可复现"><a href="#开源可复现" class="headerlink" title="开源可复现"></a>开源可复现</h2><h3 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h3><p><a href="https://github.com/qipeng/golden-retriever" target="_blank" rel="noopener">golden-retriever</a></p><h3 id="复现效果"><a href="#复现效果" class="headerlink" title="复现效果"></a>复现效果</h3><p>暂无</p><h2 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h2><p>hotpotqa 开放域 问答 问题生成 多步 EMNLP2019</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读理解 </tag>
            
            <tag> 个人论文理解 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
